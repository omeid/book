<html class="js flexbox fontface" lang="en" style=""><head><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Real World OCaml</title><link rel="stylesheet" href="css/app.css"/><script src="js/min/modernizr-min.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a href="toc.html" class="to-chapter"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body">
  <section xmlns="http://www.w3.org/1999/xhtml" id="lists-and-patterns" data-type="chapter">
    <h1>Lists and Patterns</h1>

    <p>This chapter will focus on two common elements of
    programming in OCaml: lists and pattern matching. Both of these
    were discussed in <a href="01-guided-tour.html#a-guided-tour" data-type="xref">Chapter 1, A Guided Tour</a>, but we'll go into more
    depth here, presenting the two topics together and using one to
    help illustrate the other.</p>

    <section id="list-basics" data-type="sect1">
      <h1>List Basics</h1>

      <p>An OCaml list is an immutable, finite sequence of elements
      of the same type. As we've seen, OCaml lists can be generated
      using a bracket-and-semicolon notation:<a data-type="indexterm" data-primary="lists" data-secondary="generation
      of">&nbsp;</a></p>

      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">open</span> <span class="nc">Core_kernel</span><span class="o">;;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre></div>

      <p>And they can also be generated using the equivalent
      <code>::</code> notation:<a data-type="indexterm" data-primary="operators" data-secondary=": :
      operator">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="operator : :">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="mi">1</span> <span class="o">::</span> <span class="o">(2</span> <span class="o">::</span> <span class="o">(3</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">))</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre><pre><span></span><span class="o">#</span> <span class="mi">1</span> <span class="o">::</span> <span class="o">2</span> <span class="o">::</span> <span class="o">3</span> <span class="o">::</span> <span class="bp">[]</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre></div>

      <p>As you can see, the <code>::</code> operator is
      right-associative, which means that we can build up lists
      without parentheses. The empty list <code>[]</code> is used
      to terminate a list. Note that the empty list is polymorphic,
      meaning it can be used with elements of any type, as you can
      see here:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">empty</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">empty</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="bp">[]</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">3</span> <span class="o">::</span> <span class="o">empty;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[3]</span>
</pre><pre><span></span><span class="o">#</span> <span class="s2">&quot;three&quot;</span> <span class="o">::</span> <span class="o">empty;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;three&quot;</span><span class="o">]</span>
</pre></div>

      <p>The way in which the <code>::</code> operator attaches
      elements to the front of a list reflects the fact that
      OCaml's lists are in fact singly linked lists. The figure
      below is a rough graphical representation of how the list
      <code>1 :: 2 :: 3 :: []</code> is laid out as a data
      structure. The final arrow (from the box containing
      <code>3</code>) points to the empty list.<a data-type="indexterm" data-primary="lists" data-secondary="structure
      of">&nbsp;</a></p>

      <figure style="float: 0">
        <img src="images/lists-and-patterns/lists_layout.png"/>
      </figure>

      <p>Each <code>::</code> essentially adds a new block to the
      proceding picture. Such a block contains two things: a
      reference to the data in that list element, and a reference
      to the remainder of the list. This is why <code>::</code> can
      extend a list without modifying it; extension allocates a new
      list element but change any of the existing ones, as you can
      see:<a data-type="indexterm" data-primary="lists" data-secondary="extension of">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">l</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="o">2</span> <span class="o">::</span> <span class="o">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">l</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">m</span> <span class="o">=</span> <span class="o">0</span> <span class="o">::</span> <span class="o">l;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">m</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[0;</span> <span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">l;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre></div>
    </section>

    <section id="using-patterns-to-extract-data-from-a-list" data-type="sect1">
      <h1>Using Patterns to Extract Data from a List</h1>

      <p>We can read data out of a list using a <code>match</code>
      statement. Here's a simple example of a recursive function
      that computes the sum of all elements of a list:<a data-type="indexterm" data-primary="match
      statements">&nbsp;</a><a data-type="indexterm" data-primary="pattern matching" data-secondary="extracting
      data with" id="PATMAT">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="extracting data from">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">sum</span> <span class="o">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">0</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">hd</span> <span class="o">+</span> <span class="o">sum</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">sum</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">sum</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">6</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">sum</span> <span class="bp">[]</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">0</span>
</pre></div>

      <p>This code follows the convention of using <code>hd</code>
      to represent the first element (or head) of the list, and
      <code>tl</code> to represent the remainder (or tail).</p>

      <p>The <code>match</code> statement in <code>sum</code> is
      really doing two things: first, it's acting as a
      case-analysis tool, breaking down the possibilities into a
      pattern-indexed list of cases. Second, it lets you name
      substructures within the data structure being matched. In
      this case, the variables <code>hd</code> and <code>tl</code>
      are bound by the pattern that defines the second case of the
      match statement. Variables that are bound in this way can be
      used in the expression to the right of the arrow for the
      pattern in question.</p>

      <p>The fact that <code>match</code> statements can be used to
      bind new variables can be a source of confusion. To see how,
      imagine we wanted to write a function that filtered out from
      a list all elements equal to a particular value. You might be
      tempted to write that code as follows, but when you do, the
      compiler will immediately warn you that something is
      wrong:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">drop_</span><span class="n">value</span> <span class="o">l</span> <span class="o">to_drop</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="o">to_drop</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">drop_</span><span class="n">value</span> <span class="o">tl</span> <span class="o">to_drop</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">drop_</span><span class="n">value</span> <span class="o">tl</span> <span class="o">to_drop</span>
  <span class="o">;;</span>
</pre><pre class="ge">Characters 106-114:
Warning 11: this match case is unused.</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">drop_</span><span class="n">value</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>Moreover, the function clearly does the wrong thing,
      filtering out all elements of the list rather than just those
      equal to the provided value, as you can see here:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">drop_</span><span class="n">value</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3]</span> <span class="o">2;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="bp">[]</span>
</pre></div>

      <p>So, what's going on?</p>

      <p>The key observation is that the appearance of
      <code>to_drop</code> in the second case doesn't imply a check
      that the first element is equal to the value
      <code>to_drop</code> passed in as an argument to
      <code>drop_value</code>. Instead, it just causes a new
      variable <code>to_drop</code> to be bound to whatever happens
      to be in the first element of the list, shadowing the earlier
      definition of <code>to_drop</code>. The third case is unused
      because it is essentially the same pattern as we had in the
      second case.</p>

      <p>A better way to write this code is not to use pattern
      matching for determining whether the first element is equal
      to <code>to_drop</code>, but to instead use an ordinary
      <code>if</code> statement:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">drop_</span><span class="n">value</span> <span class="o">l</span> <span class="o">to_drop</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="o">ne</span><span class="n">w_tl</span> <span class="o">=</span> <span class="o">drop_</span><span class="n">value</span> <span class="o">tl</span> <span class="o">to_drop</span> <span class="k">in</span>
      <span class="k">if</span> <span class="o">hd</span> <span class="o">=</span> <span class="o">to_drop</span> <span class="k">then</span> <span class="o">ne</span><span class="n">w_tl</span> <span class="k">else</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">ne</span><span class="n">w_tl</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">drop_</span><span class="n">value</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">drop_</span><span class="n">value</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3]</span> <span class="o">2;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">3]</span>
</pre></div>

      <p>Note that if we wanted to drop a particular literal value
      (rather than a value that was passed in), we could do this
      using something like our original implementation of
      <code>drop_value</code>:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">drop_zero</span> <span class="o">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="o">0</span>  <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">drop_zero</span> <span class="o">tl</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">drop_zero</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">drop_zero</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">drop_zero</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;0;3];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre></div>
    </section>

    <section id="limitations-and-blessings-of-pattern-matching" data-type="sect1">
      <h1>Limitations (and Blessings) of Pattern Matching</h1>

      <p>The preceding example highlights an important fact about
      patterns, which is that they can't be used to express
      arbitrary conditions. Patterns can characterize the layout of
      a data structure and can even include literals, as in the
      <code>drop_zero</code> example, but that's where they stop. A
      pattern can check if a list has two elements, but it can't
      check if the first two elements are equal to each
      other.<a data-type="indexterm" data-primary="data structures" data-secondary="pattern matching and">&nbsp;</a></p>

      <p>You can think of patterns as a specialized sublanguage
      that can express a limited (though still quite rich) set of
      conditions. The fact that the pattern language is limited
      turns out to be a very good thing, making it possible to
      build better support for patterns in the compiler. In
      particular, both the efficiency of <code>match</code>
      statements and the ability of the compiler to detect errors
      in matches depend on the constrained nature of patterns.</p>

      <section id="performance" data-type="sect2">
        <h2>Performance</h2>

        <p>Naively, you might think that it would be necessary to
        check each case in a <code>match</code> in sequence to
        figure out which one fires. If the cases of a match were
        guarded by arbitrary code, that would be the case. But
        OCaml is often able to generate machine code that jumps
        directly to the matched case based on an efficiently chosen
        set of runtime checks.</p>

        <p>As an example, consider the following rather silly
        functions for incrementing an integer by one. The first is
        implemented with a <code>match</code> statement, and the
        second with a sequence of <code>if</code> statements:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">plus_one_match</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">0</span> <span class="o">-&gt;</span> <span class="mi">1</span>
    <span class="o">|</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="o">2</span>
    <span class="o">|</span> <span class="o">2</span> <span class="o">-&gt;</span> <span class="o">3</span>
    <span class="o">|</span> <span class="o">3</span> <span class="o">-&gt;</span> <span class="o">4</span>
    <span class="o">|</span> <span class="o">4</span> <span class="o">-&gt;</span> <span class="o">5</span>
    <span class="o">|</span> <span class="o">5</span> <span class="o">-&gt;</span> <span class="o">6</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">plus_one_match</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">plus_one_if</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">if</span>      <span class="n">x</span> <span class="o">=</span> <span class="o">0</span> <span class="k">then</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="o">2</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="o">2</span> <span class="k">then</span> <span class="o">3</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="o">3</span> <span class="k">then</span> <span class="o">4</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="o">4</span> <span class="k">then</span> <span class="o">5</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="o">5</span> <span class="k">then</span> <span class="o">6</span>
    <span class="k">else</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">plus_one_if</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>Note the use of <code>_</code> in the above match. This
        is a wildcard pattern that matches any value, but without
        binding a variable name to the value in question.</p>

        <p>If you benchmark these functions, you'll see that
        <code>plus_one_if</code> is considerably slower than
        <code>plus_one_match</code>, and the advantage gets larger
        as the number of cases increases. Here, we'll benchmark
        these functions using the <code>core_bench</code> library,
        which can be installed by running <code>opam install
        core_bench</code> from the command line.</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">#re</span><span class="n">quire</span> <span class="s2">&quot;core_bench&quot;</span><span class="o">;;</span>
</pre><pre class="ge">/home/travis/.opam/4.04.2/lib/textutils: added to search path
/home/travis/.opam/4.04.2/lib/textutils/textutils.cma: loaded
/home/travis/.opam/4.04.2/lib/core_bench: added to search path
/home/travis/.opam/4.04.2/lib/core_bench/core_bench.cma: loaded</pre><pre><span></span><span class="o">#</span> <span class="k">open</span> <span class="nc">Core_bench</span><span class="o">;;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">[</span> <span class="nn">Bench</span><span class="p">.</span><span class="nn">Test</span><span class="p">.</span><span class="n">create</span> <span class="o">~name:</span><span class="s2">&quot;plus_one_match&quot;</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
        <span class="o">ignore</span> <span class="o">(plus_one_match</span> <span class="mi">10</span><span class="o">))</span>
  <span class="o">;</span> <span class="nn">Bench</span><span class="p">.</span><span class="nn">Test</span><span class="p">.</span><span class="n">create</span> <span class="o">~name:</span><span class="s2">&quot;plus_one_if&quot;</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
        <span class="o">ignore</span> <span class="o">(plus_one_if</span> <span class="mi">10</span><span class="o">))</span> <span class="o">]</span>
  <span class="o">|&gt;</span> <span class="nn">Bench</span><span class="p">.</span><span class="n">bench</span>
  <span class="o">;;</span>
</pre><pre class="ge">Estimated testing time 20s (2 benchmarks x 10s). Change using -quota SECS.
┌────────────────┬──────────┐
│ Name           │ Time/Run │
├────────────────┼──────────┤
│ plus_one_match │  34.86ns │
│ plus_one_if    │  54.89ns │
└────────────────┴──────────┘</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div>

        <p>Here's another, less artificial example. We can rewrite
        the <code>sum</code> function we described earlier in the
        chapter using an <code>if</code> statement rather than a
        match. We can then use the functions <code>is_empty</code>,
        <code>hd_exn</code>, and <code>tl_exn</code> from the
        <code>List</code> module to deconstruct the list, allowing
        us to implement the entire function without pattern
        matching:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">sum_if</span> <span class="o">l</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">is_empty</span> <span class="o">l</span> <span class="k">then</span> <span class="o">0</span>
    <span class="k">else</span> <span class="nn">List</span><span class="p">.</span><span class="n">hd_exn</span> <span class="o">l</span> <span class="o">+</span> <span class="o">sum_if</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">tl_exn</span> <span class="o">l)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">sum_if</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>Again, we can benchmark these to see the difference:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">numbers</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">range</span> <span class="o">0</span> <span class="mi">1000</span> <span class="k">in</span>
  <span class="o">[</span> <span class="nn">Bench</span><span class="p">.</span><span class="nn">Test</span><span class="p">.</span><span class="n">create</span> <span class="o">~name:</span><span class="s2">&quot;sum_if&quot;</span> <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="o">ignore</span> <span class="o">(sum_if</span> <span class="o">numbers))</span>
  <span class="o">;</span> <span class="nn">Bench</span><span class="p">.</span><span class="nn">Test</span><span class="p">.</span><span class="n">create</span> <span class="o">~name:</span><span class="s2">&quot;sum&quot;</span>    <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="o">ignore</span> <span class="o">(sum</span> <span class="o">numbers))</span> <span class="o">]</span>
  <span class="o">|&gt;</span> <span class="nn">Bench</span><span class="p">.</span><span class="n">bench</span>
  <span class="o">;;</span>
</pre><pre class="ge">Estimated testing time 20s (2 benchmarks x 10s). Change using -quota SECS.
┌────────┬──────────┐
│ Name   │ Time/Run │
├────────┼──────────┤
│ sum_if │  62.00us │
│ sum    │  17.99us │
└────────┴──────────┘</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div>

        <p>In this case, the <code>match</code>-based
        implementation is many times faster than the
        <code>if</code>-based implementation. The difference comes
        because we need to effectively do the same work multiple
        times, since each function we call has to reexamine the
        first element of the list to determine whether or not it's
        the empty cell. With a <code>match</code> statement, this
        work happens exactly once per list element.</p>

        <p>This is a more general phenomena: pattern matching is very
        efficient, and pattern matching code is usually a win over
        what you might write by hand.</p>
      </section>

      <section id="detecting-errors" data-type="sect2">
        <h2>Detecting Errors</h2>

        <p>The error-detecting capabilities of <code>match</code>
        statements are if anything more important than their
        performance. We've already seen one example of OCaml's
        ability to find problems in a pattern match: in our broken
        implementation of <code>drop_value</code>, OCaml warned us
        that the final case was redundant. There are no algorithms
        for determining if a predicate written in a general-purpose
        language is redundant, but it can be solved reliably in the
        context of patterns.<a data-type="indexterm" data-primary="match
        statements">&nbsp;</a><a data-type="indexterm" data-primary="errors" data-secondary="detecting with match
        statements">&nbsp;</a></p>

        <p>OCaml also checks <code>match</code> statements for
        exhaustiveness. Consider what happens if we modify
        <code>drop_zero</code> by deleting the handler for one of
        the cases. As you can see, the compiler will produce a
        warning that we've missed a case, along with an example of
        an unmatched pattern:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">drop_zero</span> <span class="o">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="o">0</span>  <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">drop_zero</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge">Characters 24-78:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
1::_</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">drop_zero</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>Even for simple examples like this, exhaustiveness
        checks are pretty useful. But as we'll see in <a href="06-variants.html#variants" data-type="xref">Chapter 6, Variants</a>,
        they become yet more valuable as you get to more
        complicated examples, especially those involving
        user-defined types. In addition to catching outright
        errors, they act as a sort of refactoring tool, guiding you
        to the locations where you need to adapt your code to deal
        with changing types.<a data-type="indexterm" data-startref="PATMAT">&nbsp;</a></p>
      </section>
    </section>

    <section id="using-the-list-module-effectively" data-type="sect1">
      <h1>Using the List Module Effectively</h1>

      <p>We've so far written a fair amount of list-munging code
      using pattern matching and recursive functions. But in real
      life, you're usually better off using the <code>List</code>
      module, which is full of reusable functions that abstract out
      common patterns for computing with lists.<a data-type="indexterm" data-primary="tables,
      creating with List module">&nbsp;</a><a data-type="indexterm" data-primary="List module" data-secondary="creating
      tables with">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="List
      module" id="Llistmod">&nbsp;</a></p>

      <p>Let's work through a concrete example to see this in
      action. We'll write a function <code>render_table</code>
      that, given a list of column headers and a list of rows,
      prints them out in a well-formatted text table, as
      follows:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="o">(render_table</span>
       <span class="o">[</span><span class="s2">&quot;language&quot;</span><span class="o">;</span><span class="s2">&quot;architect&quot;</span><span class="o">;</span><span class="s2">&quot;first release&quot;</span><span class="o">]</span>
       <span class="o">[</span> <span class="o">[</span><span class="s2">&quot;Lisp&quot;</span> <span class="o">;</span><span class="s2">&quot;John McCarthy&quot;</span> <span class="o">;</span><span class="s2">&quot;1958&quot;</span><span class="o">]</span> <span class="o">;</span>
         <span class="o">[</span><span class="s2">&quot;C&quot;</span>    <span class="o">;</span><span class="s2">&quot;Dennis Ritchie&quot;</span><span class="o">;</span><span class="s2">&quot;1969&quot;</span><span class="o">]</span> <span class="o">;</span>
         <span class="o">[</span><span class="s2">&quot;ML&quot;</span>   <span class="o">;</span><span class="s2">&quot;Robin Milner&quot;</span>  <span class="o">;</span><span class="s2">&quot;1973&quot;</span><span class="o">]</span> <span class="o">;</span>
         <span class="o">[</span><span class="s2">&quot;OCaml&quot;</span><span class="o">;</span><span class="s2">&quot;Xavier Leroy&quot;</span>  <span class="o">;</span><span class="s2">&quot;1996&quot;</span><span class="o">]</span> <span class="o">;</span>
       <span class="o">]);;</span>
</pre><pre class="ge">| language | architect      | first release |
|----------+----------------+---------------|
| Lisp     | John McCarthy  | 1958          |
| C        | Dennis Ritchie | 1969          |
| ML       | Robin Milner   | 1973          |
| OCaml    | Xavier Leroy   | 1996          |</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div>

      <p>The first step is to write a function to compute the
      maximum width of each column of data. We can do this by
      converting the header and each row into a list of integer
      lengths, and then taking the element-wise max of those lists
      of lengths. Writing the code for all of this directly would
      be a bit of a chore, but we can do it quite concisely by
      making use of three functions from the <code>List</code>
      module: <code>map</code>, <code>map2_exn</code>, and
      <code>fold</code>.</p>

      <p><code>List.map</code> is the simplest to explain. It takes
      a list and a function for transforming elements of that list,
      and returns a new list with the transformed elements. Thus,
      we can write:<a data-type="indexterm" data-primary="List module" data-secondary="List.map">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~f:</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="o">[</span><span class="s2">&quot;Hello&quot;</span><span class="o">;</span> <span class="s2">&quot;World!&quot;</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[5;</span> <span class="o">6]</span>
</pre></div>

      <p><code>List.map2_exn</code> is similar to
      <code>List.map</code>, except that it takes two lists and a
      function for combining them. Thus, we might write:<a data-type="indexterm" data-primary="List
      module" data-secondary="List.map2_exn">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">~f:</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3]</span> <span class="o">[3;2;</span><span class="mi">1</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[3;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre></div>

      <p>The <code>_exn</code> is there because the function throws
      an exception if the lists are of mismatched length:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">~f:</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3]</span> <span class="o">[3;2;</span><span class="mi">1</span><span class="o">;0];;</span>
</pre><pre class="ge">Exception: (Invalid_argument "length mismatch in map2_exn: 3 &lt;&gt; 4 ").</pre></div>

      <p><code>List.fold</code> is the most complicated of the
      three, taking three arguments: a list to process, an initial
      accumulator value, and a function for updating the
      accumulator. <code>List.fold</code> walks over the list from
      left to right, updating the accumulator at each step and
      returning the final value of the accumulator when it's done.
      You can see some of this by looking at the type-signature for
      <code>fold</code>:<a data-type="indexterm" data-primary="List module" data-secondary="List.fold">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">init:</span><span class="k">&#39;</span><span class="o">accum</span> <span class="o">-&gt;</span> <span class="o">f:(</span><span class="k">&#39;</span><span class="o">accum</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">accum)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">accum</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>We can use <code>List.fold</code> for something as simple
      as summing up a list:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~init:0</span> <span class="o">~f:(+)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3;4];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>

      <p>This example is particularly simple because the
      accumulator and the list elements are of the same type. But
      <code>fold</code> is not limited to such cases. We can for
      example use <code>fold</code> to reverse a list, in which
      case the accumulator is itself a list:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~init:</span><span class="bp">[]</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="o">list</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="o">list)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3;4];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[4;</span> <span class="o">3;</span> <span class="o">2;</span> <span class="mi">1</span><span class="o">]</span>
</pre></div>

      <p>Let's bring our three functions together to compute the
      maximum column widths:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">ma</span><span class="n">x_widths</span> <span class="o">header</span> <span class="o">ro</span><span class="n">ws</span> <span class="o">=</span>
    <span class="k">let</span> <span class="o">lengths</span> <span class="o">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~f:</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="o">l</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">ro</span><span class="n">ws</span>
      <span class="o">~init:(lengths</span> <span class="o">header)</span>
      <span class="o">~f:(</span><span class="k">fun</span> <span class="o">acc</span> <span class="o">ro</span><span class="n">w</span> <span class="o">-&gt;</span>
          <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">~f:</span><span class="nn">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">acc</span> <span class="o">(lengths</span> <span class="o">ro</span><span class="n">w</span><span class="o">))</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">ma</span><span class="n">x_widths</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">list</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>Using <code>List.map</code> we define the function
      <code>lengths</code>, which converts a list of strings to a
      list of integer lengths. <code>List.fold</code> is then used
      to iterate over the rows, using <code>map2_exn</code> to take
      the max of the accumulator with the lengths of the strings in
      each row of the table, with the accumulator initialized to
      the lengths of the header row.</p>

      <p>Now that we know how to compute column widths, we can
      write the code to generate the line that separates the header
      from the rest of the text table. We'll do this in part by
      mapping <code>String.make</code> over the lengths of the
      columns to generate a string of dashes of the appropriate
      length. We'll then join these sequences of dashes together
      using <code>String.concat</code>, which concatenates a list
      of strings with an optional separator string, and
      <code>^</code>, which is a pairwise string concatenation
      function, to add the delimiters on the outside:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">render_separator</span> <span class="n">widths</span> <span class="o">=</span>
    <span class="k">let</span> <span class="o">pieces</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">widths</span>
        <span class="o">~f:(</span><span class="k">fun</span> <span class="n">w</span> <span class="o">-&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="o">(</span><span class="n">w</span> <span class="o">+</span> <span class="o">2)</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="s2">&quot;|&quot;</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~sep:</span><span class="s2">&quot;+&quot;</span> <span class="o">pieces</span> <span class="o">^</span> <span class="s2">&quot;|&quot;</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">render_separator</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">render_separator</span> <span class="o">[3;6;2];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;|-----+--------+----|&quot;</span>
</pre></div>

      <p>Note that we make the line of dashes two larger than the
      provided width to provide some whitespace around each entry
      in the table.<a data-type="indexterm" data-primary="strings" data-secondary="concatenation
      of">&nbsp;</a><a data-type="indexterm" data-primary="String.concat">&nbsp;</a><a data-type="indexterm" data-primary="List
      module" data-secondary="String.concat and">&nbsp;</a></p>

      <div data-type="note">
        <h1>Performance of String.concat and ^</h1>

        <p>In the preceding code we’ve concatenated strings two
        different ways: <code>String.concat</code>, which operates
        on lists of strings; and <code>^</code>, which is a
        pairwise operator. You should avoid <code>^</code> for
        joining long numbers of strings, since it allocates a new
        string every time it runs. Thus, the following code</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">s</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span> <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span>  <span class="o">^</span> <span class="s2">&quot;.&quot;</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">s</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;.......&quot;</span>
</pre></div>

        <p>will allocate strings of length 2, 3, 4, 5, 6 and 7,
        whereas this code</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">[</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">;</span><span class="s2">&quot;.&quot;</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">s</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;.......&quot;</span>
</pre></div>

        <p>allocates one string of size 7, as well as a list of
        length 7. At these small sizes, the differences don't
        amount to much, but for assembling large strings, it can be
        a serious performance issue.</p>
      </div>

      <p>Now we need code for rendering a row with data in it.
      We'll first write a function called <code>pad</code>, for
      padding out a string to a specified length plus one blank
      space on both sides:<a data-type="indexterm" data-primary="strings" data-secondary="padding of">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">pad</span> <span class="o">s</span> <span class="o">length</span> <span class="o">=</span>
    <span class="s2">&quot; &quot;</span> <span class="o">^</span> <span class="o">s</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="o">(length</span> <span class="o">-</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="o">s</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="sc">&#39; &#39;</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">pad</span> <span class="o">:</span> <span class="o">string</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">pad</span> <span class="s2">&quot;hello&quot;</span> <span class="mi">10</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot; hello      &quot;</span>
</pre></div>

      <p>We can render a row of data by merging together the padded
      strings. Again, we'll use <code>List.map2_exn</code> for
      combining the list of data in the row with the list of
      widths:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">render_ro</span><span class="n">w</span> <span class="o">ro</span><span class="n">w</span> <span class="n">widths</span> <span class="o">=</span>
    <span class="k">let</span> <span class="o">padded</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map2_exn</span> <span class="o">ro</span><span class="n">w</span> <span class="n">widths</span> <span class="o">~f:pad</span> <span class="k">in</span>
    <span class="s2">&quot;|&quot;</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~sep:</span><span class="s2">&quot;|&quot;</span> <span class="o">padded</span> <span class="o">^</span> <span class="s2">&quot;|&quot;</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">render_ro</span><span class="n">w</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">render_ro</span><span class="n">w</span> <span class="o">[</span><span class="s2">&quot;Hello&quot;</span><span class="o">;</span><span class="s2">&quot;World&quot;</span><span class="o">]</span> <span class="o">[</span><span class="mi">10</span><span class="o">;</span><span class="mi">15</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;| Hello      | World           |&quot;</span>
</pre></div>

      <p>Now we can bring this all together in a single function
      that renders the table:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">render_table</span> <span class="o">header</span> <span class="o">ro</span><span class="n">ws</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">widths</span> <span class="o">=</span> <span class="o">ma</span><span class="n">x_widths</span> <span class="o">header</span> <span class="o">ro</span><span class="n">ws</span> <span class="k">in</span>
    <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~sep:</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
      <span class="o">(render_ro</span><span class="n">w</span> <span class="o">header</span> <span class="n">widths</span>
       <span class="o">::</span> <span class="o">render_separator</span> <span class="n">widths</span>
       <span class="o">::</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">ro</span><span class="n">ws</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="o">ro</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="o">render_ro</span><span class="n">w</span> <span class="o">ro</span><span class="n">w</span> <span class="n">widths</span><span class="o">)</span>
      <span class="o">)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">render_table</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">list</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <section id="more-useful-list-functions" data-type="sect2">
        <h2>More Useful List Functions</h2>

        <p>The previous example we worked through touched on only
        three of the functions in <code>List</code>. We won't cover
        the entire interface (for that you should look at the
        <a href="http://realworldocaml.org/doc">online docs</a>),
        but a few more functions are useful enough to mention
        here.</p>

        <section id="combining-list-elements-with-list.reduce" data-type="sect3">
          <h3>Combining list elements with List.reduce</h3>

          <p><code>List.fold</code>, which we described earlier, is
          a very general and powerful function. Sometimes, however,
          you want something simpler and easier to use. One such
          function is <code>List.reduce</code>, which is
          essentially a specialized version of
          <code>List.fold</code> that doesn't require an explicit
          starting value, and whose accumulator has to consume and
          produce values of the same type as the elements of the
          list it applies to.<a data-type="indexterm" data-primary="elements" data-secondary="combining with
          List.reduce">&nbsp;</a><a data-type="indexterm" data-primary="List
          module" data-secondary="List.reduce">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="combining elements
          in">&nbsp;</a></p>

          <p>Here's the type signature:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">reduce</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">f:(</span><span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

          <p><code>reduce</code> returns an optional result,
          returning <code>None</code> when the input list is
          empty.</p>

          <p>Now we can see <code>reduce</code> in action:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">reduce</span> <span class="o">~f:(+)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3;4;5];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">15</span>
</pre><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">reduce</span> <span class="o">~f:(+)</span> <span class="bp">[]</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">option</span> <span class="o">=</span> <span class="nc">None</span>
</pre></div>
        </section>

        <section id="filtering-with-list.filter-and-list.filter_map" data-type="sect3">
          <h3>Filtering with List.filter and List.filter_map</h3>

          <p>Very often when processing lists, you wants to
          restrict your attention to a subset of the values on your
          list. The <code>List.filter</code> function is one way of
          doing that:<a data-type="indexterm" data-primary="lists" data-secondary="filtering values
          in">&nbsp;</a><a data-type="indexterm" data-primary="values" data-secondary="filtering with
          List.filter">&nbsp;</a><a data-type="indexterm" data-primary="List module" data-secondary="List.filter">&nbsp;</a></p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">mod</span> <span class="o">2</span> <span class="o">=</span> <span class="o">0)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3;4;5];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[2;</span> <span class="o">4]</span>
</pre></div>

          <p>Note that the <code>mod</code> used above is an infix
          operator, as described in <a href="02-variables-and-functions.html#variables-and-functions" data-type="xref">Chapter 2, Variables And Functions</a>.</p>

          <p>Sometimes, you want to both transform and filter as
          part of the same computation. In that case,
          <code>List.filter_map</code> is what you need. The
          function passed to <code>List.filter_map</code> returns
          an optional value, and <code>List.filter_map</code> drops
          all elements for which <code>None</code> is returned.</p>

          <p>Here's an example. The following function computes
            a list of file extensions from a list of files, piping the
            results through <code>List.dedup</code> to remove
            duplicates. Note that this example
            uses <code>String.rsplit2</code> from teh String module to
            split a string on the rightmost appearance of a given
            character:<a data-type="indexterm" data-primary="lists" data-secondary="duplicate
              removal">&nbsp;</a><a data-type="indexterm" data-primary="duplicates, removing">&nbsp;</a></p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">e</span><span class="n">xtensions</span> <span class="o">filenames</span> <span class="o">=</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">filter_map</span> <span class="o">filenames</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="o">fname</span> <span class="o">-&gt;</span>
        <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">rsplit2</span> <span class="o">~on:</span><span class="sc">&#39;.&#39;</span> <span class="o">fname</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">None</span>  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="nc">None</span>
        <span class="o">|</span> <span class="nc">Some</span> <span class="o">(_,e</span><span class="n">xt</span><span class="o">)</span> <span class="o">-&gt;</span>
          <span class="nc">Some</span> <span class="o">e</span><span class="n">xt</span><span class="o">)</span>
    <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">dedup</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">e</span><span class="n">xtensions</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">e</span><span class="n">xtensions</span> <span class="o">[</span><span class="s2">&quot;foo.c&quot;</span><span class="o">;</span> <span class="s2">&quot;foo.ml&quot;</span><span class="o">;</span> <span class="s2">&quot;bar.ml&quot;</span><span class="o">;</span> <span class="s2">&quot;bar.mli&quot;</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;c&quot;</span><span class="o">;</span> <span class="s2">&quot;ml&quot;</span><span class="o">;</span> <span class="s2">&quot;mli&quot;</span><span class="o">]</span>
</pre></div>

          <p>The preceding code is also an example of an Or
          pattern, which allows you to have multiple subpatterns
          within a larger pattern. In this case, <code>None | Some
          ("",_)</code> is an Or pattern. As we'll see later, Or
          patterns can be nested anywhere within larger
          patterns.</p>
        </section>

        <section id="partitioning-with-list.partition_tf" data-type="sect3">
          <h3>Partitioning with List.partition_tf</h3>

          <p>Another useful operation that's closely related to
          filtering is partitioning. The function
          <code>List.partition_tf</code> takes a list and a
          function for computing a Boolean condition on the list
          elements, and returns two lists. The <code>tf</code> in
          the name is a mnemonic to remind the user that
          <code>true</code> elements go to the first list and
          <code>false</code> ones go to the second. Here's an
          example:<a data-type="indexterm" data-primary="elements" data-secondary="partitioning with
          List.partition_tf">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="partitioning elements
          in">&nbsp;</a><a data-type="indexterm" data-primary="List module" data-secondary="List.partition_tf">&nbsp;</a></p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">is_ocaml_source</span> <span class="o">s</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">rsplit2</span> <span class="o">s</span> <span class="o">~on:</span><span class="sc">&#39;.&#39;</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(_,(</span><span class="s2">&quot;ml&quot;</span><span class="o">|</span><span class="s2">&quot;mli&quot;</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">is_ocaml_source</span> <span class="o">:</span> <span class="o">string</span> <span class="o">-&gt;</span> <span class="o">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">(ml_files,other_files)</span> <span class="o">=</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">partition_tf</span> <span class="o">[</span><span class="s2">&quot;foo.c&quot;</span><span class="o">;</span> <span class="s2">&quot;foo.ml&quot;</span><span class="o">;</span> <span class="s2">&quot;bar.ml&quot;</span><span class="o">;</span> <span class="s2">&quot;bar.mli&quot;</span><span class="o">]</span>  <span class="o">~f:is_ocaml_source;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">ml_files</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;foo.ml&quot;</span><span class="o">;</span> <span class="s2">&quot;bar.ml&quot;</span><span class="o">;</span> <span class="s2">&quot;bar.mli&quot;</span><span class="o">]</span>
<span class="k">val</span> <span class="o">other_files</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;foo.c&quot;</span><span class="o">]</span>
</pre></div>
        </section>

        <section id="combining-lists" data-type="sect3">
          <h3>Combining lists</h3>

          <p>Another very common operation on lists is
          concatenation. The list module actually comes with a few
          different ways of doing this. First, there's
          <code>List.append</code>, for concatenating a pair of
          lists:<a data-type="indexterm" data-primary="lists" data-secondary="combining">&nbsp;</a><a data-type="indexterm" data-primary="List
          module" data-secondary="List.append">&nbsp;</a></p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">append</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3]</span> <span class="o">[4;5;6];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3;</span> <span class="o">4;</span> <span class="o">5;</span> <span class="o">6]</span>
</pre></div>

          <p>There's also <code>@</code>, an operator equivalent of
          <code>List.append</code>:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3]</span> <span class="o">@</span> <span class="o">[4;5;6];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3;</span> <span class="o">4;</span> <span class="o">5;</span> <span class="o">6]</span>
</pre></div>

          <p>In addition, there is <code>List.concat</code>, for
          concatenating a list of lists:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat</span> <span class="o">[[</span><span class="mi">1</span><span class="o">;2];[3;4;5];[6];</span><span class="bp">[]</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3;</span> <span class="o">4;</span> <span class="o">5;</span> <span class="o">6]</span>
</pre></div>

          <p>Here's an example of using <code>List.concat</code> along
            with <code>List.map</code> to compute a recursive listing of
            a directory tree. </p> 
	  <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">module</span> <span class="nc">Sys</span> <span class="o">=</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Sys</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="o">ls_rec</span> <span class="o">s</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">is_file_exn</span> <span class="o">~follo</span><span class="n">w_symlinks</span><span class="o">:</span><span class="bp">true</span> <span class="o">s</span>
    <span class="k">then</span> <span class="o">[s]</span>
    <span class="k">else</span>
      <span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="o">s</span>
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="o">sub</span> <span class="o">-&gt;</span> <span class="o">ls_rec</span> <span class="o">(</span><span class="nn">Filename</span><span class="p">.</span><span class="n">concat</span> <span class="o">s</span> <span class="o">sub))</span>
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">module</span> <span class="nc">Sys</span> <span class="o">=</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">Sys</span>
<span class="k">val</span> <span class="o">ls_rec</span> <span class="o">:</span> <span class="o">string</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

          <p>Note that this example uses some functions from
            the <code>Sys</code> module from <code>Core</code> for
            accessing the filesystem.  It also uses <code>^/</code>,
	    an infix operator for adding a new element to a string
	    representing a file path, which is an alias
	    of <code>Filename.concat</code>.</p>

          <p>The preceding combination of <code>List.map</code> and
            <code>List.concat</code> is common enough that there is a
            function <code>List.concat_map</code> that combines these
            into one, more efficient operation:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">ls_rec</span> <span class="o">s</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">is_file_exn</span> <span class="o">~follo</span><span class="n">w_symlinks</span><span class="o">:</span><span class="bp">true</span> <span class="o">s</span>
    <span class="k">then</span> <span class="o">[s]</span>
    <span class="k">else</span>
      <span class="nn">Sys</span><span class="p">.</span><span class="n">ls_dir</span> <span class="o">s</span>
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat_map</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="o">sub</span> <span class="o">-&gt;</span> <span class="o">ls_rec</span> <span class="o">(</span><span class="nn">Filename</span><span class="p">.</span><span class="n">concat</span> <span class="o">s</span> <span class="o">sub))</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">ls_rec</span> <span class="o">:</span> <span class="o">string</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
        </section>
      </section>
    </section>

    <section id="tail-recursion" data-type="sect1">
      <h1>Tail Recursion</h1>

      <p>The only way to compute the length of an OCaml list is to
      walk the list from beginning to end. As a result, computing
      the length of a list takes time linear in the size of the
      list. Here's a simple function for doing so:<a data-type="indexterm" data-primary="List
      module" data-secondary="List.init">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="computing length
      of">&nbsp;</a><a data-type="indexterm" data-primary="tail recursion">&nbsp;</a> <a data-type="indexterm" data-primary="recursion" data-secondary="tail
      recursion">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">length</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">0</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">length</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">length</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">3</span>
</pre></div>

      <p>This looks simple enough, but you'll discover that this
      implementation runs into problems on very large lists, as
      we'll show in the following code:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">make_list</span> <span class="o">n</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">init</span> <span class="o">n</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">);;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">make_list</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">length</span> <span class="o">(make_list</span> <span class="mi">10</span><span class="o">);;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">10</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">length</span> <span class="o">(make_list</span> <span class="mi">10_000_000</span><span class="o">);;</span>
</pre><pre class="ge">Stack overflow during evaluation (looping recursion?).</pre></div>

      <p>The preceding example creates lists using
      <code>List.init</code>, which takes an integer <code>n</code>
      and a function <code>f</code> and creates a list of length
      <code>n</code>, where the data for each element is created by
      calling <code>f</code> on the index of that element.</p>

      <p>To understand where the error in the above example comes
      from, you need to learn a bit more about how function calls
      work. Typically, a function call needs some space to keep
      track of information associated with the call, such as the
      arguments passed to the function, or the location of the code
      that needs to start executing when the function call is
      complete. To allow for nested function calls, this
      information is typically organized in a stack, where a new
      <em>stack frame</em> is allocated for each nested function
      call, and then deallocated when the function call is
      complete.<a data-type="indexterm" data-primary="stack frames">&nbsp;</a></p>

      <p>And that's the problem with our call to
      <code>length</code>: it tried to allocate 10 million stack
      frames, which exhausted the available stack space. Happily,
      there's a way around this problem. Consider the following
      alternative implementation:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">length_plus_n</span> <span class="o">l</span> <span class="o">n</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">n</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">length_plus_n</span> <span class="o">tl</span> <span class="o">(n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">length_plus_n</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">length</span> <span class="o">l</span> <span class="o">=</span> <span class="o">length_plus_n</span> <span class="o">l</span> <span class="o">0</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">length</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3;4];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">4</span>
</pre></div>

      <p>This implementation depends on a helper function,
      <code>length_plus_n</code>, that computes the length of a
      given list plus a given <code>n</code>. In practice,
      <code>n</code> acts as an accumulator in which the answer is
      built up, step by step. As a result, we can do the additions
      along the way rather than doing them as we unwind the nested
      sequence of function calls, as we did in our first
      implementation of <code>length</code>.</p>

      <p>The advantage of this approach is that the recursive call
      in <code>length_plus_n</code> is a <em>tail call</em>. We'll
      explain more precisely what it means to be a tail call
      shortly, but the reason it's important is that tail calls
      don't require the allocation of a new stack frame, due to
      what is called the <em>tail-call optimization</em>. A
      recursive function is said to be <em>tail recursive</em> if
      all of its recursive calls are tail calls.
      <code>length_plus_n</code> is indeed tail recursive, and as a
      result, <code>length</code> can take a long list as input
      without blowing the stack:<a data-type="indexterm" data-primary="tail calls">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">length</span> <span class="o">(make_list</span> <span class="mi">10_000_000</span><span class="o">);;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">10000000</span>
</pre></div>

      <p>So when is a call a tail call? Let's think about the
      situation where one function (the <em>caller</em>) invokes
      another (the <em>callee</em>). The invocation is considered a
      tail call when the caller doesn't do anything with the value
      returned by the callee except to return it. The tail-call
      optimization makes sense because, when a caller makes a tail
      call, the caller's stack frame need never be used again, and
      so you don't need to keep it around. Thus, instead of
      allocating a new stack frame for the callee, the compiler is
      free to reuse the caller's stack frame.</p>

      <p>Tail recursion is important for more than just lists.
      Ordinary nontail recursive calls are reasonable when dealing
      with data structures like binary trees, where the depth of
      the tree is logarithmic in the size of your data. But when
      dealing with situations where the depth of the sequence of
      nested calls is on the order of the size of your data, tail
      recursion is usually the right approach.</p>
    </section>

    <section id="terser-and-faster-patterns" data-type="sect1">
      <h1>Terser and Faster Patterns</h1>

      <p>Now that we know more about how lists and patterns work,
      let's consider how we can improve on an example from <a href="01-guided-tour.html#recursive-list-functions" data-type="xref">Chapter 1, Recursive List Functions</a>: the function
      <code>destutter</code>, which removes sequential duplicates
      from a list. Here's the implementation that was described
      earlier:<a data-type="indexterm" data-primary="destutter function">&nbsp;</a><a data-type="indexterm" data-primary="pattern matching" data-secondary="terser and faster
      patterns" id="PTTRNMAT">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="duplicate
      removal">&nbsp;</a><a data-type="indexterm" data-primary="duplicates, removing">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">destutter</span> <span class="o">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="o">[hd]</span> <span class="o">-&gt;</span> <span class="o">[hd]</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">hd</span><span class="k">&#39;</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="o">hd</span> <span class="o">=</span> <span class="o">hd</span><span class="k">&#39;</span> <span class="k">then</span> <span class="o">destutter</span> <span class="o">(hd</span><span class="k">&#39;</span> <span class="o">::</span> <span class="o">tl)</span>
      <span class="k">else</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">destutter</span> <span class="o">(hd</span><span class="k">&#39;</span> <span class="o">::</span> <span class="o">tl)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">destutter</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>We'll consider some ways of making this code more concise
      and more efficient.</p>

      <p>First, let's consider efficiency. One problem with the
      <code>destutter</code> code above is that it in some cases
      re-creates on the righthand side of the arrow a value that
      already existed on the lefthand side. Thus, the pattern
      <code>[hd] -&gt; [hd]</code> actually allocates a new list
      element, when really, it should be able to just return the
      list being matched. We can reduce allocation here by using an
      <code>as</code> pattern, which allows us to declare a name
      for the thing matched by a pattern or subpattern. While we're
      at it, we'll use the <code>function</code> keyword to
      eliminate the need for an explicit match:<a data-type="indexterm" data-primary="function
      keyword">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">destutter</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="k">as</span> <span class="o">l</span> <span class="o">-&gt;</span> <span class="o">l</span>
    <span class="o">|</span> <span class="o">[_]</span> <span class="k">as</span> <span class="o">l</span> <span class="o">-&gt;</span> <span class="o">l</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">(hd</span><span class="k">&#39;</span> <span class="o">::</span> <span class="o">_</span> <span class="k">as</span> <span class="o">tl)</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="o">hd</span> <span class="o">=</span> <span class="o">hd</span><span class="k">&#39;</span> <span class="k">then</span> <span class="o">destutter</span> <span class="o">tl</span>
      <span class="k">else</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">destutter</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">destutter</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>We can further collapse this by combining the first two
      cases into one, using an Or pattern:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">destutter</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">[_]</span> <span class="k">as</span> <span class="o">l</span> <span class="o">-&gt;</span> <span class="o">l</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">(hd</span><span class="k">&#39;</span> <span class="o">::</span> <span class="o">_</span> <span class="k">as</span> <span class="o">tl)</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="o">hd</span> <span class="o">=</span> <span class="o">hd</span><span class="k">&#39;</span> <span class="k">then</span> <span class="o">destutter</span> <span class="o">tl</span>
      <span class="k">else</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">destutter</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">destutter</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>We can make the code slightly terser now by using a
      <code>when</code> clause. A <code>when</code> clause allows
      us to add an extra precondition to a pattern in the form of
      an arbitrary OCaml expression. In this case, we can use it to
      include the check on whether the first two elements are
      equal:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">destutter</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">[_]</span> <span class="k">as</span> <span class="o">l</span> <span class="o">-&gt;</span> <span class="o">l</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">(hd</span><span class="k">&#39;</span> <span class="o">::</span> <span class="o">_</span> <span class="k">as</span> <span class="o">tl)</span> <span class="k">when</span> <span class="o">hd</span> <span class="o">=</span> <span class="o">hd</span><span class="k">&#39;</span> <span class="o">-&gt;</span> <span class="o">destutter</span> <span class="o">tl</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">destutter</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">destutter</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <aside data-type="sidebar">
        <h5>Polymorphic Compare</h5>

        <p>In the preceding <code>destutter</code> example, we made
        use of the fact that OCaml lets us test equality between
        values of any type, using the <code>=</code> operator.
        Thus, we can write:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">3</span> <span class="o">=</span> <span class="o">4;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">[3;4;5]</span> <span class="o">=</span> <span class="o">[3;4;5];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">[</span><span class="nc">Some</span> <span class="o">3;</span> <span class="nc">None</span><span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="nc">None</span><span class="o">;</span> <span class="nc">Some</span> <span class="o">3];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre></div>

        <p>Indeed, if we look at the type of the equality operator,
        we'll see that it is polymorphic:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">(=);;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="o">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>OCaml comes with a whole family of polymorphic
        comparison operators, including the standard infix
        comparators, <code>&lt;</code>, <code>&gt;=</code>, etc.,
        as well as the function <code>compare</code> that returns
        <code>-1</code>, <code>0</code>, or <code>1</code> to flag
        whether the first operand is smaller than, equal to, or
        greater than the second, respectively.</p>

        <p>You might wonder how you could build functions like
        these yourself if OCaml didn't come with them built in. It
        turns out that you <em>can't</em> build these functions on
        your own. OCaml's polymorphic comparison functions are
        built into the runtime to a low level. These comparisons
        are polymorphic on the basis of ignoring almost everything
        about the types of the values that are being compared,
        paying attention only to the structure of the values as
        they're laid out in memory.</p>

        <p>Polymorphic compare does have some limitations. For
        example, it will fail at runtime if it encounters a
        function value:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);;</span>
</pre><pre class="ge">Exception: (Invalid_argument "compare: functional value").</pre></div>

        <p>Similarly, it will fail on values that come from outside
        the OCaml heap, like values from C bindings. But it will
        work in a reasonable way for other kinds of values.</p>

        <p>For simple atomic types, polymorphic compare has the
        semantics you would expect: for floating-point numbers and
        integers, polymorphic compare corresponds to the expected
        numerical comparison functions. For strings, it's a
        lexicographic comparison.</p>

        <p>Sometimes, however, the type-ignoring nature of
        polymorphic compare is a problem, particularly when you
        have your own notion of equality and ordering that you want
        to impose. We'll discuss this issue more, as well as some
        of the other downsides of polymorphic compare, in <a href="13-maps-and-hashtables.html#maps-and-hash-tables" data-type="xref">Chapter 13, Maps And Hash Tables</a>.</p>
      </aside>

      <p>Note that <code>when</code> clauses have some downsides.
      As we noted earlier, the static checks associated with
      pattern matches rely on the fact that patterns are restricted
      in what they can express. Once we add the ability to add an
      arbitrary condition to a pattern, something will be lost. In
      particular, the ability of the compiler to determine if a
      match is exhaustive, or if some case is redundant, is
      compromised.</p>

      <p>Consider the following function, which takes a list of
      optional values, and returns the number of those values that
      are <code>Some</code>. Because this implementation uses
      <code>when</code> clauses, the compiler can't tell that the
      code is exhaustive:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">count_some</span> <span class="o">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">0</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="o">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_none</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">count_some</span> <span class="o">tl</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="o">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">count_some</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge">Characters 28-161:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_
(However, some guarded clause may match this value.)</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">count_some</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">option</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>Despite the warning, the function does work fine:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">count_some</span> <span class="o">[</span><span class="nc">Some</span> <span class="o">3;</span> <span class="nc">None</span><span class="o">;</span> <span class="nc">Some</span> <span class="o">4];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">2</span>
</pre></div>

      <p>If we add another redundant case without a
      <code>when</code> clause, the compiler will stop complaining
      about exhaustiveness and won't produce a warning about the
      redundancy.</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">count_some</span> <span class="o">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">0</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="o">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_none</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">count_some</span> <span class="o">tl</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="o">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">count_some</span> <span class="o">tl</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="c">(* unreachable *)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">count_some</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">option</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>Probably a better approach is to simply drop the second
      <code>when</code> clause:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">count_some</span> <span class="o">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">0</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="o">tl</span> <span class="k">when</span> <span class="nn">Option</span><span class="p">.</span><span class="n">is_none</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">count_some</span> <span class="o">tl</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">count_some</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">count_some</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">option</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>This is a little less clear, however, than the direct
      pattern-matching solution, where the meaning of each pattern
      is clearer on its own:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">count_some</span> <span class="o">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">0</span>
    <span class="o">|</span> <span class="nc">None</span>   <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">count_some</span> <span class="o">tl</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">_</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">count_some</span> <span class="o">tl</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">count_some</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">option</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>The takeaway from all of this is although
      <code>when</code> clauses can be useful, we should prefer
      patterns wherever they are sufficient.</p>

      <p>As a side note, the above implementation of
      <code>count_some</code> is longer than necessary; even worse,
      it is not tail recursive. In real life, you would probably
      just use the <code>List.count</code> function from
      <code>Core_kernel</code>:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">count_some</span> <span class="o">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">count</span> <span class="o">~f:</span><span class="nn">Option</span><span class="p">.</span><span class="n">is_some</span> <span class="o">l;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">count_some</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">option</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>
    </section>
  </section>
</article></div><a class="next-chapter" href="04-files-modules-and-programs.html"><div class="content"><h1><small>Next: Chapter 04</small>Files, Modules, and Programs</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://plus.google.com/111219778721183890368">+hickey</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2014 Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script><script src="js/discourse.js"></script></body></html>