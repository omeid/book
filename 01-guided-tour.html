<html class="js flexbox fontface" lang="en" style=""><head><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Real World OCaml</title><link rel="stylesheet" href="css/app.css"/><script src="js/min/modernizr-min.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a href="toc.html" class="to-chapter"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body">
  <section xmlns="http://www.w3.org/1999/xhtml" id="a-guided-tour" data-type="chapter">
    <h1>A Guided Tour</h1>

    <p>This chapter gives an overview of OCaml by walking through a
    series of small examples that cover most of the major features
    of the language. This should provide a sense of what OCaml can
    do, without getting too deep into any one topic.</p>

    <p>Throughout the book we're going to
    use <code>Core_kernel</code>, a more full-featured and capable
    replacement for OCaml's standard library. We'll also
    use <span class="command"><em>utop</em></span>, a shell that lets
    you type in expressions and evaluate them interactively.
      <span class="command"><em>utop</em></span> is an
    easier-to-use version of OCaml's standard toplevel (which you can
    start by typing <em>ocaml</em> at the command line). These
    instructions will assume you're
    using <span class="command"><em>utop</em></span>, but the ordinary
    toplevel should mostly work fine.</p>

    <div data-type="note">
      <h1><code>Core</code>, <code>Core_kernel</code> and
      portability</h1>

      <p><code>Core_kernel</code> is actually part of a more
      expansive library called <code>Core</code>. We use
      <code>Core_kernel</code> here because it is portable to every
      platform that OCaml runs on, unlike <code>Core</code>, which
      only works on Unix-like platforms, including Linux and MacOS.
      If you want your code to run on Windows or Javascript, you
      need to stick to <code>Core_kernel</code>.</p>

      <p>You should check out <code>Core</code> if you'll be running
      only on Unix. <code>Core</code> includes a lot of useful
      functionality, including an excellent command line parsing
      library and modules that provide access to low-level operating
      systems facilities from mutexes to sockets. We'll discuss some
      of the additional functionality provided by <code>Core</code>
      later in the book.</p>
    </div>

    <p>Before getting started, make sure you have a working OCaml
    installation so you can try out the examples as you read
    through the chapter.</p>

    <section id="ocaml-as-a-calculator" data-type="sect1">
      <h1>OCaml as a Calculator</h1>

      <p>Our first step is to open <code>Core_kernel</code>:

	<a data-type="indexterm" data-primary="OCaml" data-secondary="numerical calculations in">&nbsp;</a>
	<a data-type="indexterm" data-primary="numerical calculations">&nbsp;</a>
	<a data-type="indexterm" data-primary="Core standard library" data-secondary="opening">&nbsp;</a> 
      </p>

      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">open</span> <span class="nc">Core_kernel</span><span class="o">;;</span>
</pre></div>

      <p>By opening <code>Core_kernel</code>, we make the
      definitions it contains available without having to reference
      <code>Core_kernel</code> explicitly. This is required for
      many of the examples in the tour and in the remainder of the
      book.</p>

      <p>Now let's try a few simple numerical calculations:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">3</span> <span class="o">+</span> <span class="o">4;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">7</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">8</span> <span class="o">/</span> <span class="o">3;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">2</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">3.5</span> <span class="o">+.</span> <span class="o">6.;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">float</span> <span class="o">=</span> <span class="o">9.5</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">30_000_000</span> <span class="o">/</span> <span class="o">300_000;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">100</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">s</span><span class="n">qrt</span> <span class="o">9.;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">float</span> <span class="o">=</span> <span class="o">3.</span>
</pre></div>

      <p>By and large, this is pretty similar to what you'd find in
      any programming language, but a few things jump right out at
      you:</p>

      <ul>
        <li>
          <p>We needed to type <code>;;</code> in order to tell the
          toplevel that it should evaluate an expression. This is a
          peculiarity of the toplevel that is not required in
          standalone programs (though it is sometimes helpful to
          include <code>;;</code> to improve OCaml's error
          reporting, by making it more explicit where a given
          top-level declaration was intended to end).</p>
        </li>

        <li>
          <p>After evaluating an expression, the toplevel first
          prints the type of the result, and then prints the result
          itself.</p>
        </li>

        <li>
          <p>Function arguments are separated by spaces instead of
          by parentheses and commas, which is more like the UNIX
          shell than it is like traditional programming languages
          such as C or Java.</p>
        </li>

        <li>
          <p>OCaml allows you to place underscores in the middle of
          numeric literals to improve readability. Note that
          underscores can be placed anywhere within a number, not
          just every three digits.</p>
        </li>

        <li>
          <p>OCaml carefully distinguishes between
          <code>float</code>, the type for floating-point numbers,
          and <code>int</code>, the type for integers. The types
          have different literals (<code>6.</code> instead of
          <code>6</code>) and different infix operators
          (<code>+.</code> instead of <code>+</code>), and OCaml
          doesn't automatically cast between these types. This can
          be a bit of a nuisance, but it has its benefits, since it
          prevents some kinds of bugs that arise in other languages
          due to unexpected differences between the behavior of
          <code>int</code> and <code>float</code>. For example, in
          many languages, <code>1 / 3</code> is zero, but <code>1 /
          3.0</code> is a third. OCaml requires you to be explicit
          about which operation you're using.</p>
        </li>
      </ul>

      <p>We can also create a variable to name the value of a given
      expression, using the <code>let</code> keyword. This is known
      as a <em>let binding</em>:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">3</span> <span class="o">+</span> <span class="o">4;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">7</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">y</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">14</span>
</pre></div>

      <p>After a new variable is created, the toplevel tells us the
      name of the variable (<code>x</code> or <code>y</code>), in
      addition to its type (<code>int</code>) and value
      (<code>7</code> or <code>14</code>).</p>

      <p>Note that there are some constraints on what identifiers
      can be used for variable names. Punctuation is excluded,
      except for <code>_</code> and <code>'</code>, and variables
      must start with a lowercase letter or an underscore. Thus,
      these are legal:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x7</span> <span class="o">=</span> <span class="o">3</span> <span class="o">+</span> <span class="o">4;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="n">x7</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">7</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x_plus_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="o">y;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="n">x_plus_y</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">2</span><span class="mi">1</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x&#39;</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="n">x&#39;</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">8</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">_</span><span class="n">x&#39;</span> <span class="o">=</span> <span class="n">x&#39;</span> <span class="o">+</span> <span class="n">x&#39;</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">_</span><span class="n">x&#39;</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">16</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">_</span><span class="n">x&#39;</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">16</span>
</pre></div>

      <p>Note that by default, <span class="command"><em>utop</em></span> doesn't bother to print out
      variables starting with an underscore.</p>

      <p>The following examples, however, are not legal:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="nc">Seven</span> <span class="o">=</span> <span class="o">3</span> <span class="o">+</span> <span class="o">4;;</span>
</pre><pre class="ge">Characters 4-9:
Error: Unbound constructor Seven</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">7</span><span class="n">x</span> <span class="o">=</span> <span class="o">7;;</span>
</pre><pre class="ge">Characters 4-6:
Error: Unknown modifier 'x' for literal 7x</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x</span><span class="o">-plus-y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="o">y;;</span>
</pre><pre class="ge">Characters 6-10:
Error: Syntax error</pre></div>

      <p>This highlights that variables can't be capitalized, can't
      begin with numbers, and can't contain dashes.</p>
    </section>

    <section id="functions-and-type-inference" data-type="sect1">
      <h1>Functions and Type Inference</h1>

      <p>The <code>let</code> syntax can also be used to define a
      function:<a data-type="indexterm" data-primary="let syntax" data-secondary="function definition
      with">&nbsp;</a><a data-type="indexterm" data-primary="functions" data-secondary="defining">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">s</span><span class="n">quare</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">s</span><span class="n">quare</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">s</span><span class="n">quare</span> <span class="o">2;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">4</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">s</span><span class="n">quare</span> <span class="o">(s</span><span class="n">quare</span> <span class="o">2);;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">16</span>
</pre></div>

      <p>Functions in OCaml are values like any other, which is why
      we use the <code>let</code> keyword to bind a function to a
      variable name, just as we use <code>let</code> to bind a
      simple value like an integer to a variable name. When using
      <code>let</code> to define a function, the first identifier
      after the <code>let</code> is the function name, and each
      subsequent identifier is a different argument to the
      function. Thus, <code>square</code> is a function with a
      single argument.</p>

      <p>Now that we're creating more interesting values like
      functions, the types have gotten more interesting too.
      <code>int -&gt; int</code> is a function type, in this case
      indicating a function that takes an <code>int</code> and
      returns an <code>int</code>. We can also write functions that
      take multiple arguments. (Note that the following example
      will not work if you haven't opened
      <code>Core_kernel</code> as was suggested
      earlier.)<a data-type="indexterm" data-primary="multi-argument
      functions">&nbsp;</a><a data-type="indexterm" data-primary="functions" data-secondary="with multiple
      arguments">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">ratio</span> <span class="n">x</span> <span class="o">y</span> <span class="o">=</span>
    <span class="nn">Float</span><span class="p">.</span><span class="n">of_int</span> <span class="n">x</span> <span class="o">/.</span> <span class="nn">Float</span><span class="p">.</span><span class="n">of_int</span> <span class="o">y</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">ratio</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">ratio</span> <span class="o">4</span> <span class="o">7;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">float</span> <span class="o">=</span> <span class="o">0.57</span><span class="mi">1428571429</span>
</pre></div>

      <p>The preceding example also happens to be our first use of
      modules. Here, <code>Float.of_int</code> refers to the
      <code>of_int</code> function contained in the
      <code>Float</code> module. This is different from what you
      might expect from an object-oriented language, where
      dot-notation is typically used for accessing a method of an
      object. Note that module names always start with a capital
      letter.</p>

      <p>The notation for the type-signature of a multiargument
      function may be a little surprising at first, but we'll
      explain where it comes from when we get to function currying
      in <a href="02-variables-and-functions.html#multi-argument-functions" data-type="xref">Chapter 2, Multi Argument Functions</a>. For the
      moment, think of the arrows as separating different arguments
      of the function, with the type after the final arrow being
      the return value. Thus, <code>int -&gt; int -&gt;
      float</code> describes a function that takes two
      <code>int</code> arguments and returns a
      <code>float</code>.</p>

      <p>We can also write functions that take other functions as
      arguments. Here's an example of a function that takes three
      arguments: a test function and two integer arguments. The
      function returns the sum of the integers that pass the
      test:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">sum_if_</span><span class="bp">true</span> <span class="o">test</span> <span class="o">first</span> <span class="o">second</span> <span class="o">=</span>
    <span class="o">(</span><span class="k">if</span> <span class="o">test</span> <span class="o">first</span> <span class="k">then</span> <span class="o">first</span> <span class="k">else</span> <span class="o">0)</span>
    <span class="o">+</span> <span class="o">(</span><span class="k">if</span> <span class="o">test</span> <span class="o">second</span> <span class="k">then</span> <span class="o">second</span> <span class="k">else</span> <span class="o">0)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">sum_if_</span><span class="bp">true</span> <span class="o">:</span> <span class="o">(int</span> <span class="o">-&gt;</span> <span class="o">bool)</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>If we look at the inferred type signature in detail, we
      see that the first argument is a function that takes an
      integer and returns a boolean, and that the remaining two
      arguments are integers. Here's an example of this function in
      action:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">e</span><span class="n">ven</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">mod</span> <span class="o">2</span> <span class="o">=</span> <span class="o">0</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">e</span><span class="n">ven</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">sum_if_</span><span class="bp">true</span> <span class="o">e</span><span class="n">ven</span> <span class="o">3</span> <span class="o">4;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">4</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">sum_if_</span><span class="bp">true</span> <span class="o">e</span><span class="n">ven</span> <span class="o">2</span> <span class="o">4;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">6</span>
</pre></div>

      <p>Note that in the definition of <code>even</code>, we used
      <code>=</code> in two different ways: once as part of the
      <code>let</code> binding that separates the thing being
      defined from its definition; and once as an equality test,
      when comparing <code>x mod 2</code> to <code>0</code>. These
      are very different operations despite the fact that they
      share some syntax.</p>

      <section id="type-inference" data-type="sect2">
        <h2>Type Inference</h2>

        <p>As the types we encounter get more complicated, you
        might ask yourself how OCaml is able to figure them out,
        given that we didn't write down any explicit type
        information.<a data-type="indexterm" data-primary="type inference" data-secondary="process of">&nbsp;</a></p>

        <p>OCaml determines the type of an expression using a
        technique called <em>type inference</em>, by which the type
        of an expression is inferred from the available type
        information about the components of that expression.</p>

        <p>As an example, let's walk through the process of
        inferring the type of <code>sum_if_true</code>:</p>

        <ol>
          <li>
            <p>OCaml requires that both branches of an
            <code>if</code> statement have the same type, so the
            expression </p>

	    <p><code>if test first then first else 0</code></p>

	    <p> requires that <code>first</code> must be the same type
            as <code>0</code>, and so <code>first</code> must be of
            type <code>int</code>. Similarly, from</p> 

	    <p><code>if test second then second else 0</code> </p>

	    <p>we can infer that <code>second</code> has type <code>int</code>.</p>
          </li>

          <li>
            <p><code>test</code> is passed <code>first</code> as an
            argument. Since <code>first</code> has type
            <code>int</code>, the input type of <code>test</code>
            must be <code>int</code>.</p>
          </li>

          <li>
            <p><code>test first</code> is used as the condition in
            an <code>if</code> statement, so the return type of
            <code>test</code> must be <code>bool</code>.</p>
          </li>

          <li>
            <p>The fact that <code>+</code> returns
            <code>int</code> implies that the return value of
            <code>sum_if_true</code> must be int.</p>
          </li>
        </ol>

        <p>Together, that nails down the types of all the
        variables, which determines the overall type of
        <code>sum_if_true</code>.</p>

        <p>Over time, you'll build a rough intuition for how the
        OCaml inference engine works, which makes it easier to
        reason through your programs. You can make it easier to
        understand the types of a given expression by adding
        explicit type annotations. These annotations don't change
        the behavior of an OCaml program, but they can serve as
        useful documentation, as well as catch unintended type
        changes. They can also be helpful in figuring out why a
        given piece of code fails to compile.</p>

        <p>Here's an annotated version of
        <code>sum_if_true</code>:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">sum_if_</span><span class="bp">true</span> <span class="o">(test</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">bool)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">int)</span> <span class="o">(y</span> <span class="o">:</span> <span class="o">int)</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span>
    <span class="o">(</span><span class="k">if</span> <span class="o">test</span> <span class="n">x</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="o">0)</span>
    <span class="o">+</span> <span class="o">(</span><span class="k">if</span> <span class="o">test</span> <span class="o">y</span> <span class="k">then</span> <span class="o">y</span> <span class="k">else</span> <span class="o">0)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">sum_if_</span><span class="bp">true</span> <span class="o">:</span> <span class="o">(int</span> <span class="o">-&gt;</span> <span class="o">bool)</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>In the above, we've marked every argument to the
        function with its type, with the final annotation
        indicating the type of the return value. Such type
        annotations can be placed on any expression in an OCaml
        program:</p>
      </section>

      <section id="inferring-generic-types" data-type="sect2">
        <h2>Inferring Generic Types</h2>

        <p>Sometimes, there isn't enough information to fully
        determine the concrete type of a given value. Consider this
        function..<a data-type="indexterm" data-primary="type inference" data-secondary="generic types">&nbsp;</a></p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">first_if_</span><span class="bp">true</span> <span class="o">test</span> <span class="n">x</span> <span class="o">y</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">test</span> <span class="n">x</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="o">y</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">first_if_</span><span class="bp">true</span> <span class="o">:</span> <span class="o">(</span><span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="o">bool)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p><code>first_if_true</code> takes as its arguments a
        function <code>test</code>, and two values, <code>x</code>
        and <code>y</code>, where <code>x</code> is to be returned
        if <code>test x</code> evaluates to <code>true</code>,
        and <code>y</code> otherwise. So what's the type of
        the <code>x</code> argument to <code>first_if_true</code>?
        There are no obvious clues such as arithmetic operators or
        literals to narrow it down. That makes it seem
        like <code>first_if_true</code> would work on values of any
        type.</p>

        <p>Indeed, if we look at the type returned by the toplevel, we
        see that rather than choose a single concrete type, OCaml has
        introduced a <em>type variable</em> <code>'a</code> to express
        that the type is generic. (You can tell it's a type variable
        by the leading single quote mark.) In particular, the type of
        the <code>test</code> argument is <code>('a -&gt;
        bool)</code>, which means that <code>test</code> is a
        one-argument function whose return value is <code>bool</code>
        and whose argument could be of any type <code>'a</code>. But,
        whatever type <code>'a</code> is, it has to be the same as the
        type of the other two arguments, <code>x</code>
        and <code>y</code>, and of the return value
        of <code>first_if_true</code>. This kind of genericity is
        called <em>parametric polymorphism</em> because it works by
        parameterizing the type in question with a type variable. It
        is very similar to generics in C# and Java. <a data-type="indexterm" data-primary="parametric
        polymorphism">&nbsp;</a><a data-type="indexterm" data-primary="type variables">&nbsp;</a></p>

        <p>Because the type of <code>first_if_true</code> is generic,
        we can write this:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">long_string</span> <span class="o">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="o">s</span> <span class="o">&gt;</span> <span class="o">6;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">long_string</span> <span class="o">:</span> <span class="o">string</span> <span class="o">-&gt;</span> <span class="o">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">first_if_</span><span class="bp">true</span> <span class="o">long_string</span> <span class="s2">&quot;short&quot;</span> <span class="s2">&quot;loooooong&quot;</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;loooooong&quot;</span>
</pre></div>

        <p>As well as this:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">big_number</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="o">3;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">big_number</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">first_if_</span><span class="bp">true</span> <span class="o">big_number</span> <span class="o">4</span> <span class="o">3;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">4</span>
</pre></div>

        <p>Both <code>long_string</code> and
        <code>big_number</code> are functions, and each is passed
        to <code>first_if_true</code> with two other arguments of
        the appropriate type (strings in the first example, and
        integers in the second). But we can't mix and match two
        different concrete types for <code>'a</code> in the same
        use of <code>first_if_true</code>:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">first_if_</span><span class="bp">true</span> <span class="o">big_number</span> <span class="s2">&quot;short&quot;</span> <span class="s2">&quot;loooooong&quot;</span><span class="o">;;</span>
</pre><pre class="ge">Characters 25-32:
Error: This expression has type string but an expression was expected of type
         int</pre></div>

        <p>In this example, <code>big_number</code> requires that
        <code>'a</code> be instantiated as <code>int</code>,
        whereas <code>"short"</code> and <code>"loooooong"</code>
        require that <code>'a</code> be instantiated as
        <code>string</code>, and they can't both be right at the
        same time.</p>

        <div data-type="note">
          <h1>Type Errors Versus Exceptions</h1>

          <p>There's a big difference in OCaml (and really in any
          compiled language) between errors that are caught at
          compile time and those that are caught at runtime. It's
          better to catch errors as early as possible in the
          development process, and compilation time is best of
          all.<a data-type="indexterm" data-primary="runtime exceptions vs. type
          errors">&nbsp;</a><a data-type="indexterm" data-primary="errors" data-secondary="runtime vs. compile
          time">&nbsp;</a><a data-type="indexterm" data-primary="exceptions" data-secondary="vs. type errors">&nbsp;</a><a data-type="indexterm" data-primary="type
          errors vs. exceptions">&nbsp;</a></p>

          <p>Working in the toplevel somewhat obscures the
          difference between runtime and compile-time errors, but
          that difference is still there. Generally, type errors
          like this one:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">add_potato</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">+</span> <span class="s2">&quot;potato&quot;</span><span class="o">;;</span>
</pre><pre class="ge">Characters 25-33:
Error: This expression has type string but an expression was expected of type
         int</pre></div>

          <p>are compile-time errors (because <code>+</code>
          requires that both its arguments be of type
          <code>int</code>), whereas errors that can't be caught by
          the type system, like division by zero, lead to runtime
          exceptions:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">is_a_multiple</span> <span class="n">x</span> <span class="o">y</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">mod</span> <span class="o">y</span> <span class="o">=</span> <span class="o">0</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">is_a_multiple</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">is_a_multiple</span> <span class="o">8</span> <span class="o">2;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">is_a_multiple</span> <span class="o">8</span> <span class="o">0;;</span>
</pre><pre class="ge">Exception: Division_by_zero.</pre></div>

          <p>The distinction here is that type errors will stop you
          whether or not the offending code is ever actually
          executed. Merely defining <code>add_potato</code> is an
          error, whereas <code>is_a_multiple</code> only fails when
          it's called, and then, only when it's called with an
          input that triggers the exception.</p>
        </div>
      </section>
    </section>

    <section id="tuples-lists-options-and-pattern-matching" data-type="sect1">
      <h1>Tuples, Lists, Options, and Pattern Matching</h1>

      <section id="tuples" data-type="sect2">
        <h2>Tuples</h2>

        <p>So far we've encountered a handful of basic types like
        <code>int</code>, <code>float</code>, and
        <code>string</code>, as well as function types like
        <code>string -&gt; int</code>. But we haven't yet talked
        about any data structures. We'll start by looking at a
        particularly simple data structure, the tuple. A tuple is
        an ordered collection of values that can each be of a
        different type. You can create a tuple by joining values
        together with a comma:<a data-type="indexterm" data-primary="tuples">&nbsp;</a><a data-type="indexterm" data-primary="data
        structures" data-secondary="tuples">&nbsp;</a></p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">a_tuple</span> <span class="o">=</span> <span class="o">(3,</span><span class="s2">&quot;three&quot;</span><span class="o">);;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">a_tuple</span> <span class="o">:</span> <span class="o">int</span> <span class="o">*</span> <span class="o">string</span> <span class="o">=</span> <span class="o">(3,</span> <span class="s2">&quot;three&quot;</span><span class="o">)</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">another_tuple</span> <span class="o">=</span> <span class="o">(3,</span><span class="s2">&quot;four&quot;</span><span class="o">,5.);;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">another_tuple</span> <span class="o">:</span> <span class="o">int</span> <span class="o">*</span> <span class="o">string</span> <span class="o">*</span> <span class="o">float</span> <span class="o">=</span> <span class="o">(3,</span> <span class="s2">&quot;four&quot;</span><span class="o">,</span> <span class="o">5.)</span>
</pre></div>

        <p>(For the mathematically inclined, <code>*</code>
          is used in the type <code>t * s</code> because that type
          corresponds to the set of all pairs containing one value of
          type <code>t</code> and one of type <code>s</code>. In other
          words, it's the <em>Cartesian product</em> of the two types,
          which is why we use <code> * </code>, the symbol for
          product.)</p>

        <p>You can extract the components of a tuple using OCaml's
        pattern-matching syntax, as shown below:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">(</span><span class="n">x</span><span class="o">,y)</span> <span class="o">=</span> <span class="o">a_tuple;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">3</span>
<span class="k">val</span> <span class="o">y</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;three&quot;</span>
</pre></div>

        <p>Here, the <code>(x,y)</code> on the left-hand side of
        the <code>let</code> binding is the pattern. This pattern lets
        us mint the new variables <code>x</code> and <code>y</code>,
        each bound to different components of the value being
        matched. These can now be used in subsequent expressions:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">x</span> <span class="o">+</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="o">y;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">8</span>
</pre></div>

        <p>Note that the same syntax is used both for constructing
        and for pattern matching on tuples.</p>

        <p>Pattern matching can also show up in function arguments.
        Here's a function for computing the distance between two
        points on the plane, where each point is represented as a
        pair of <code>float</code>s. The pattern-matching syntax
        lets us get at the values we need with a minimum of
        fuss:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">distance</span> <span class="o">(</span><span class="n">x1</span><span class="o">,y</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">x2</span><span class="o">,y2)</span> <span class="o">=</span>
    <span class="o">s</span><span class="n">qrt</span> <span class="o">((</span><span class="n">x1</span> <span class="o">-.</span> <span class="n">x2</span><span class="o">)</span> <span class="o">**</span> <span class="o">2.</span> <span class="o">+.</span> <span class="o">(y</span><span class="mi">1</span> <span class="o">-.</span> <span class="o">y2)</span> <span class="o">**</span> <span class="o">2.)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">distance</span> <span class="o">:</span> <span class="o">float</span> <span class="o">*</span> <span class="o">float</span> <span class="o">-&gt;</span> <span class="o">float</span> <span class="o">*</span> <span class="o">float</span> <span class="o">-&gt;</span> <span class="o">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>The <code>**</code> operator used above is for raising a
        floating-point number to a power.</p>

        <p>This is just a first taste of pattern matching. Pattern
        matching is a pervasive tool in OCaml, and as you'll see,
        it has surprising power.</p>
      </section>

      <section id="lists" data-type="sect2">
        <h2>Lists</h2>

        <p>Where tuples let you combine a fixed number of items,
        potentially of different types, lists let you hold any
        number of items of the same type. Consider the following
        example:<a data-type="indexterm" data-primary="data structures" data-secondary="lists" id="DSlists">&nbsp;</a></p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">languages</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;OCaml&quot;</span><span class="o">;</span><span class="s2">&quot;Perl&quot;</span><span class="o">;</span><span class="s2">&quot;C&quot;</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">languages</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;OCaml&quot;</span><span class="o">;</span> <span class="s2">&quot;Perl&quot;</span><span class="o">;</span> <span class="s2">&quot;C&quot;</span><span class="o">]</span>
</pre></div>

        <p>Note that you can't mix elements of different types in
        the same list, unlike tuples:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">numbers</span> <span class="o">=</span> <span class="o">[3;</span><span class="s2">&quot;four&quot;</span><span class="o">;5];;</span>
</pre><pre class="ge">Characters 17-23:
Error: This expression has type string but an expression was expected of type
         int</pre></div>

        <section id="the-list-module" data-type="sect3">
          <h3>The List module</h3>

          <p><code>Core_kernel</code> comes with a
          <code>List</code> module that has a rich collection of
          functions for working with lists. We can access values
          from within a module by using dot notation. For example,
          this is how we compute the length of a list:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="o">languages;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">3</span>
</pre></div>

          <p>Here's something a little more complicated. We can
          compute the list of the lengths of each language as
          follows:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">languages</span> <span class="o">~f:</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[5;</span> <span class="o">4;</span> <span class="mi">1</span><span class="o">]</span>
</pre></div>

          <p><code>List.map</code> takes two arguments: a list and
          a function for transforming the elements of that list. It
          returns a new list with the transformed elements and does
          not modify the original list.</p>

          <p>Notably, the function passed to <code>List.map</code>
          is passed under a <em>labeled argument</em>
          <code>~f</code>. Labeled arguments are specified by name
          rather than by position, and thus allow you to change the
          order in which arguments are presented to a function
          without changing its behavior, as you can see
          here:<a data-type="indexterm" data-primary="arguments" data-secondary="labeled arguments">&nbsp;</a><a data-type="indexterm" data-primary="labeled
          arguments">&nbsp;</a></p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~f:</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="o">languages;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[5;</span> <span class="o">4;</span> <span class="mi">1</span><span class="o">]</span>
</pre></div>

          <p>We'll learn more about labeled arguments and why
          they're important in <a href="02-variables-and-functions.html#variables-and-functions" data-type="xref">Chapter 2, Variables And Functions</a>.</p>
        </section>

        <section id="constructing-lists-with" data-type="sect3">
          <h3>Constructing lists with ::</h3>

          <p>In addition to constructing lists using brackets, we can
          use the list constructor <code>::</code> for adding elements
          to the front of a list:<a data-type="indexterm" data-primary="operators" data-secondary=": :
          operator">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="operator : :">&nbsp;</a></p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="s2">&quot;French&quot;</span> <span class="o">::</span> <span class="s2">&quot;Spanish&quot;</span> <span class="o">::</span> <span class="o">languages;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;French&quot;</span><span class="o">;</span> <span class="s2">&quot;Spanish&quot;</span><span class="o">;</span> <span class="s2">&quot;OCaml&quot;</span><span class="o">;</span> <span class="s2">&quot;Perl&quot;</span><span class="o">;</span> <span class="s2">&quot;C&quot;</span><span class="o">]</span>
</pre></div>

          <p>Here, we're creating a new and extended list, not
          changing the list we started with, as you can see
          below:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">languages;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;OCaml&quot;</span><span class="o">;</span> <span class="s2">&quot;Perl&quot;</span><span class="o">;</span> <span class="s2">&quot;C&quot;</span><span class="o">]</span>
</pre></div>

          <div data-type="note">
            <h1>Semicolons Versus Commas</h1>

            <p>Unlike many other languages, OCaml uses semicolons
            to separate list elements in lists rather than commas.
            Commas, instead, are used for separating elements in a
            tuple. If you try to use commas in a list, you'll see
            that your code compiles but doesn't do quite what you
            might expect:<a data-type="indexterm" data-primary="commas vs.
            semicolons">&nbsp;</a><a data-type="indexterm" data-primary="semicolons vs. commas">&nbsp;</a></p>
            <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">[</span><span class="s2">&quot;OCaml&quot;</span><span class="o">,</span> <span class="s2">&quot;Perl&quot;</span><span class="o">,</span> <span class="s2">&quot;C&quot;</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">(string</span> <span class="o">*</span> <span class="o">string</span> <span class="o">*</span> <span class="o">string)</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[(</span><span class="s2">&quot;OCaml&quot;</span><span class="o">,</span> <span class="s2">&quot;Perl&quot;</span><span class="o">,</span> <span class="s2">&quot;C&quot;</span><span class="o">)]</span>
</pre></div>

            <p>In particular, rather than a list of three strings,
            what we have is a singleton list containing a
            three-tuple of strings.</p>

            <p>This example uncovers the fact that commas create a
            tuple, even if there are no surrounding parens. So, we
            can write:</p>
            <div class="highlight"><pre><span></span><span class="o">#</span> <span class="mi">1</span><span class="o">,2,3;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">*</span> <span class="o">int</span> <span class="o">*</span> <span class="o">int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">2,</span> <span class="o">3)</span>
</pre></div>

            <p>to allocate a tuple of integers. This is generally
            considered poor style and should be avoided.</p>
          </div>

          <p>The bracket notation for lists is really just
          syntactic sugar for <code>::</code>. Thus, the following
          declarations are all equivalent. Note that
          <code>[]</code> is used to represent the empty list and
          that <code>::</code> is right-associative:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre><pre><span></span><span class="o">#</span> <span class="mi">1</span> <span class="o">::</span> <span class="o">(2</span> <span class="o">::</span> <span class="o">(3</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">));;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre><pre><span></span><span class="o">#</span> <span class="mi">1</span> <span class="o">::</span> <span class="o">2</span> <span class="o">::</span> <span class="o">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3]</span>
</pre></div>

          <p>The <code>::</code> constructor can only be used for
          adding one element to the front of the list, with the
          list terminating at <code>[]</code>, the empty list.
          There's also a list concatenation operator,
          <code>@</code>, which can concatenate two lists:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3]</span> <span class="o">@</span> <span class="o">[4;5;6];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3;</span> <span class="o">4;</span> <span class="o">5;</span> <span class="o">6]</span>
</pre></div>

          <p>It's important to remember that, unlike
          <code>::</code>, this is not a constant-time operation.
          Concatenating two lists takes time proportional to the
          length of the first list.</p>
        </section>

        <section id="list-patterns-using-match" data-type="sect3">
          <h3>List patterns using match</h3>

          <p>The elements of a list can be accessed through pattern
          matching. List patterns are based on the two list
          constructors, <code>[]</code> and <code>::</code>. Here's
          a simple example:<a data-type="indexterm" data-primary="pattern matching" data-secondary="in
          lists">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="pattern matching">&nbsp;</a></p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">my_fa</span><span class="n">vorite_language</span> <span class="o">(my_fa</span><span class="n">vorite</span> <span class="o">::</span> <span class="o">the_rest)</span> <span class="o">=</span>
    <span class="o">my_fa</span><span class="n">vorite</span>
  <span class="o">;;</span>
</pre><pre class="ge">Characters 25-66:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">my_fa</span><span class="n">vorite_language</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

          <p>By pattern matching using <code>::</code>, we've
          isolated and named the first element of the list
          (<code>my_favorite</code>) and the remainder of the list
          (<code>the_rest</code>). If you know Lisp or Scheme, what
          we've done is the equivalent of using the functions
          <code>car</code> and <code>cdr</code> to isolate the
          first element of a list and the remainder of that
          list.</p>

          <p>As you can see, however, the toplevel did not like this
          definition and spit out a warning indicating that the
          pattern is not exhaustive. This means that there are values
          of the type in question that won't be captured by the
          pattern. The warning even gives an example of a value that
          doesn't match the provided pattern, in
          particular, <code>[]</code>, the empty list. If we try to
          run <code>my_favorite_language</code>, we'll see that it
          works on nonempty lists and fails on empty ones:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="o">my_fa</span><span class="n">vorite_language</span> <span class="o">[</span><span class="s2">&quot;English&quot;</span><span class="o">;</span><span class="s2">&quot;Spanish&quot;</span><span class="o">;</span><span class="s2">&quot;French&quot;</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;English&quot;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">my_fa</span><span class="n">vorite_language</span> <span class="bp">[]</span><span class="o">;;</span>
</pre><pre class="ge">Exception: "Match_failure //toplevel//:2:25".</pre></div>

          <p>You can avoid these warnings, and more importantly
          make sure that your code actually handles all of the
          possible cases, by using a <code>match</code> statement
          instead.</p>

          <p>A <code>match</code> statement is a kind of juiced-up
          version of the <code>switch</code> statement found in C and
          Java. It essentially lets you list a sequence of patterns,
          separated by pipe characters. Note that the one before the
          first case is optional. The compiler then dispatches to the
          code following the first matching pattern. As we've already
          seen, the pattern can mint new variables that correspond to
          parts of the value being matched.</p>

          <p>Here's a new version of
          <code>my_favorite_language</code> that uses
          <code>match</code> and doesn't trigger a compiler
          warning:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">my_fa</span><span class="n">vorite_language</span> <span class="o">languages</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">languages</span> <span class="k">with</span>
    <span class="o">|</span> <span class="o">first</span> <span class="o">::</span> <span class="o">the_rest</span> <span class="o">-&gt;</span> <span class="o">first</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="s2">&quot;OCaml&quot;</span> <span class="c">(* A good default! *)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">my_fa</span><span class="n">vorite_language</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">my_fa</span><span class="n">vorite_language</span> <span class="o">[</span><span class="s2">&quot;English&quot;</span><span class="o">;</span><span class="s2">&quot;Spanish&quot;</span><span class="o">;</span><span class="s2">&quot;French&quot;</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;English&quot;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">my_fa</span><span class="n">vorite_language</span> <span class="bp">[]</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;OCaml&quot;</span>
</pre></div>

          <p>The preceding code also includes our first comment.
          OCaml comments are bounded by <code>(*</code> and
          <code>*)</code> and can be nested arbitrarily and cover
          multiple lines. There's no equivalent of C++-style
          single-line comments that are prefixed by
          <code>//</code>.</p>

          <p>The first pattern, <code>first :: the_rest</code>,
          covers the case where <code>languages</code> has at least
          one element, since every list except for the empty list
          can be written down with one or more <code>::</code>'s.
          The second pattern, <code>[]</code>, matches only the
          empty list. These cases are exhaustive, since every list
          is either empty or has at least one element, a fact that
          is verified by the compiler.</p>
        </section>

        <section id="recursive-list-functions" data-type="sect3">
          <h3>Recursive list functions</h3>

          <p>Recursive functions, or functions that call themselves,
          are an important part of working in OCaml or really any
          functional language. The typical approach to designing a
          recursive function is to separate the logic into a set
          of <em>base cases</em> that can be solved directly and a set
          of <em>inductive cases</em>, where the function breaks the
          problem down into smaller pieces and then calls itself to
          solve those smaller problems.<a data-type="indexterm" data-primary="recursive functions" data-secondary="list
          functions">&nbsp;</a><a data-type="indexterm" data-primary="lists" data-secondary="recursive list functions">&nbsp;</a></p>

          <p>When writing recursive list functions, this separation
          between the base cases and the inductive cases is often
          done using pattern matching. Here's a simple example of a
          function that sums the elements of a list:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">sum</span> <span class="o">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">0</span>                   <span class="c">(* base case *)</span>
    <span class="o">|</span> <span class="o">hd</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span> <span class="o">hd</span> <span class="o">+</span> <span class="o">sum</span> <span class="o">tl</span>   <span class="c">(* inductive case *)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">sum</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">sum</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">6</span>
</pre></div>

          <p>Following the common OCaml idiom, we use
          <code>hd</code> to refer to the head of the list and
          <code>tl</code> to refer to the tail. Note that we had to
          use the <code>rec</code> keyword to allow
          <code>sum</code> to refer to itself. As you might
          imagine, the base case and inductive case are different
          arms of the match.</p>

          <p>Logically, you can think of the evaluation of a simple
          recursive function like <code>sum</code> almost as if it
          were a mathematical equation whose meaning you were
          unfolding step by step:</p>
          <div class="highlight"><pre><span></span><span class="o">sum</span> <span class="o">[</span><span class="mi">1</span><span class="o">;2;3]</span>
<span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">sum</span> <span class="o">[2;3]</span>
<span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">(2</span> <span class="o">+</span> <span class="o">sum</span> <span class="o">[3])</span>
<span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">(2</span> <span class="o">+</span> <span class="o">(3</span> <span class="o">+</span> <span class="o">sum</span> <span class="bp">[]</span><span class="o">))</span>
<span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">(2</span> <span class="o">+</span> <span class="o">(3</span> <span class="o">+</span> <span class="o">0))</span>
<span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">(2</span> <span class="o">+</span> <span class="o">3)</span>
<span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">5</span>
<span class="o">=</span> <span class="o">6</span>
</pre></div>

          <p>This suggests a reasonable mental model for what OCaml
          is actually doing to evaluate a recursive function.</p>

          <p>We can introduce more complicated list patterns as
          well. Here's a function for removing sequential
          duplicates:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">remo</span><span class="n">ve_sequential_duplicates</span> <span class="o">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="o">first</span> <span class="o">::</span> <span class="o">second</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="o">first</span> <span class="o">=</span> <span class="o">second</span> <span class="k">then</span> <span class="o">remo</span><span class="n">ve_sequential_duplicates</span> <span class="o">(second</span> <span class="o">::</span> <span class="o">tl)</span>
      <span class="k">else</span> <span class="o">first</span> <span class="o">::</span> <span class="o">remo</span><span class="n">ve_sequential_duplicates</span> <span class="o">(second</span> <span class="o">::</span> <span class="o">tl)</span>
  <span class="o">;;</span>
</pre><pre class="ge">Characters 46-236:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::[]</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">remo</span><span class="n">ve_sequential_duplicates</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

          <p>Again, the first arm of the match is the base case, and
          the second is the inductive case. Unfortunately, this code
          has a problem, as indicated by the warning message. In
          particular, it doesn't handle one-element lists. We can fix
          this warning by adding another case to the match:</p>
          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="k">rec</span> <span class="o">remo</span><span class="n">ve_sequential_duplicates</span> <span class="o">list</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">list</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="o">[hd]</span> <span class="o">-&gt;</span> <span class="o">[hd]</span>
    <span class="o">|</span> <span class="o">hd</span><span class="mi">1</span> <span class="o">::</span> <span class="o">hd2</span> <span class="o">::</span> <span class="o">tl</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="o">hd</span><span class="mi">1</span> <span class="o">=</span> <span class="o">hd2</span> <span class="k">then</span> <span class="o">remo</span><span class="n">ve_sequential_duplicates</span> <span class="o">(hd2</span> <span class="o">::</span> <span class="o">tl)</span>
      <span class="k">else</span> <span class="o">hd</span><span class="mi">1</span> <span class="o">::</span> <span class="o">remo</span><span class="n">ve_sequential_duplicates</span> <span class="o">(hd2</span> <span class="o">::</span> <span class="o">tl)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">remo</span><span class="n">ve_sequential_duplicates</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">remo</span><span class="n">ve_sequential_duplicates</span> <span class="o">[</span><span class="s2">&quot;hey&quot;</span><span class="o">;</span><span class="s2">&quot;hey&quot;</span><span class="o">;</span><span class="s2">&quot;hey&quot;</span><span class="o">;</span><span class="s2">&quot;man!&quot;</span><span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;hey&quot;</span><span class="o">;</span> <span class="s2">&quot;man!&quot;</span><span class="o">]</span>
</pre></div>

          <p>Note that this code used another variant of the list
          pattern, <code>[hd]</code>, to match a list with a single
          element. We can do this to match a list with any fixed
          number of elements; for example, <code>[x;y;z]</code>
          will match any list with exactly three elements and will
          bind those elements to the variables <code>x</code>,
          <code>y</code>, and <code>z</code>.</p>

          <p>In the last few examples, our list processing code
          involved a lot of recursive functions. In practice, this
          isn't usually necessary. Most of the time, you'll find
          yourself happy to use the iteration functions found in
          the <code>List</code> module. But it's good to know how
          to use recursion when you need to do something
          new.<a data-type="indexterm" data-startref="DSlists">&nbsp;</a></p>
        </section>
      </section>

      <section id="options" data-type="sect2">
        <h2>Options</h2>

        <p>Another common data structure in OCaml is
        the <em>option</em>. An option is used to express that a value
        might or might not be present. For
        example:<a data-type="indexterm" data-primary="options">&nbsp;</a><a data-type="indexterm" data-primary="data
        structures" data-secondary="options">&nbsp;</a></p> <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">di</span><span class="n">vide</span> <span class="n">x</span> <span class="o">y</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">y</span> <span class="o">=</span> <span class="o">0</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="o">y)</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">di</span><span class="n">vide</span> <span class="o">:</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>The function <code>divide</code> either returns
        <code>None</code> if the divisor is zero, or
        <code>Some</code> of the result of the division otherwise.
        <code>Some</code> and <code>None</code> are constructors
        that let you build optional values, just as <code>::</code>
        and <code>[]</code> let you build lists. You can think of
        an option as a specialized list that can only have zero or
        one elements.</p>

        <p>To examine the contents of an option, we use pattern
        matching, as we did with tuples and lists. Let's see how
        this plays out in a small example. We'll write a function
        that takes a filename, and returns a version of that
        filename with the file extension (the part after the dot)
        downcased. We'll base this on the function
        <code>String.rsplit2</code> to split the string based on
        the rightmost period found in the string. Note that
        <code>String.rsplit2</code> has return type <code>(string *
        string) option</code>, returning <code>None</code> when no
        character was found to split on.</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">do</span><span class="n">wncase_extension</span> <span class="o">filename</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">String</span><span class="p">.</span><span class="n">rsplit2</span> <span class="o">filename</span> <span class="o">~on:</span><span class="sc">&#39;.&#39;</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="o">filename</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(base,e</span><span class="n">xt</span><span class="o">)</span> <span class="o">-&gt;</span> 
      <span class="o">base</span> <span class="o">^</span> <span class="s2">&quot;.&quot;</span> <span class="o">^</span> <span class="nn">String</span><span class="p">.</span><span class="n">lowercase</span> <span class="o">e</span><span class="n">xt</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">do</span><span class="n">wncase_extension</span> <span class="o">:</span> <span class="o">string</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~f:do</span><span class="n">wncase_extension</span>
    <span class="o">[</span> <span class="s2">&quot;Hello_World.TXT&quot;</span><span class="o">;</span> <span class="s2">&quot;Hello_World.TXT&quot;</span><span class="o">;</span> <span class="s2">&quot;Hello_World&quot;</span> <span class="o">]</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;Hello_World.txt&quot;</span><span class="o">;</span> <span class="s2">&quot;Hello_World.txt&quot;</span><span class="o">;</span> <span class="s2">&quot;Hello_World&quot;</span><span class="o">]</span>
</pre></div>

        <p>Note that we used the <code>^</code> operator for
        concatenating strings. The concatenation operator is
        provided as part of the <code>Pervasives</code> module,
        which is automatically opened in every OCaml program.</p>

        <div data-type="note">
          <h1>Nesting lets with let and in</h1>

          <p><code>log_entry</code> was our first use of
          <code>let</code> to define a new variable within the body
          of a function. A <code>let</code> paired with an
          <code>in</code> can be used to introduce a new binding
          within any local scope, including a function body. The
          <code>in</code> marks the beginning of the scope within
          which the new variable can be used. Thus, we could
          write:<a data-type="indexterm" data-primary="let syntax" data-secondary="nested let binding">&nbsp;</a></p>

          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">7</span> <span class="k">in</span>
  <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">14</span>
</pre></div>

          <p>Note that the scope of the <code>let</code> binding is
          terminated by the double-semicolon, so the value of
          <code>x</code> is no longer available:</p>

          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">x</span><span class="o">;;</span>
</pre><pre class="ge">Characters 0-1:
Error: Unbound value x</pre></div>

          <p>We can also have multiple <code>let</code> statements
          in a row, each one adding a new variable binding to what
          came before:</p>

          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">7</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">in</span>
  <span class="n">x</span> <span class="o">+</span> <span class="o">y</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">56</span>
</pre></div>

          <p>This kind of nested <code>let</code> binding is a
          common way of building up a complex expression, with each
          <code>let</code> naming some component, before combining
          them in one final expression.</p>
        </div>

        <p>Options are important because they are the standard way
        in OCaml to encode a value that might not be there; there's
        no such thing as a <code>NullPointerException</code> in
        OCaml. This is different from most other languages,
        including Java and C#, where most if not all data types are
        <em>nullable</em>, meaning that, whatever their type is,
        any given value also contains the possibility of being a
        null value. In such languages, null is lurking
        everywhere.<a data-type="indexterm" data-primary="datatypes" data-secondary="nullable">&nbsp;</a></p>

        <p>In OCaml, however, missing values are explicit. A value
        of type <code>string * string</code> always contains two
        well-defined values of type <code>string</code>. If you
        want to allow, say, the first of those to be absent, then
        you need to change the type to <code>string option *
        string</code>. As we'll see in <a href="07-error-handling.html#error-handling" data-type="xref">Chapter 7, Error Handling</a>, this explicitness allows the
        compiler to provide a great deal of help in making sure
        you're correctly handling the possibility of missing
        data.</p>
      </section>
    </section>

    <section id="records-and-variants" data-type="sect1">
      <h1>Records and Variants</h1>

      <p>So far, we've only looked at data structures that were
      predefined in the language, like lists and tuples. But OCaml
      also allows us to define new data types. Here's a toy example
      of a data type representing a point in two-dimensional
      space:<a data-type="indexterm" data-primary="datatypes" data-secondary="defining new">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">type</span> <span class="o">point2d</span> <span class="o">=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="o">float;</span> <span class="o">y</span> <span class="o">:</span> <span class="o">float</span> <span class="o">};;</span>
</pre><pre class="ge"><span></span><span class="k">type</span> <span class="o">point2d</span> <span class="o">=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="o">float;</span> <span class="o">y</span> <span class="o">:</span> <span class="o">float;</span> <span class="o">}</span>
</pre></div>

      <p><code>point2d</code> is a <em>record</em> type, which you
      can think of as a tuple where the individual fields are
      named, rather than being defined positionally. Record types
      are easy enough to construct:<a data-type="indexterm" data-primary="records" data-secondary="record
      types">&nbsp;</a><a data-type="indexterm" data-primary="datatypes" data-secondary="record types">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">p</span> <span class="o">=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">=</span> <span class="o">3.;</span> <span class="o">y</span> <span class="o">=</span> <span class="o">-4.</span> <span class="o">};;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">p</span> <span class="o">:</span> <span class="o">point2d</span> <span class="o">=</span> <span class="o">{</span><span class="n">x</span> <span class="o">=</span> <span class="o">3.;</span> <span class="o">y</span> <span class="o">=</span> <span class="o">-4.}</span>
</pre></div>

      <p>And we can get access to the contents of these types using
      pattern matching:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">magnitude</span> <span class="o">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x_pos</span><span class="o">;</span> <span class="o">y</span> <span class="o">=</span> <span class="o">y_pos</span> <span class="o">}</span> <span class="o">=</span>
    <span class="o">s</span><span class="n">qrt</span> <span class="o">(</span><span class="n">x_pos</span> <span class="o">**</span> <span class="o">2.</span> <span class="o">+.</span> <span class="o">y_pos</span> <span class="o">**</span> <span class="o">2.);;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">magnitude</span> <span class="o">:</span> <span class="o">point2d</span> <span class="o">-&gt;</span> <span class="o">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>The pattern match here binds the variable
      <code>x_pos</code> to the value contained in the
      <code>x</code> field, and the variable <code>y_pos</code> to
      the value in the <code>y</code> field.</p>

      <p>We can write this more tersely using what's called
      <em>field punning</em>. In particular, when the name of the
      field and the name of the variable it is bound to coincide,
      we don't have to write them both down. Using this, our
      magnitude function can be rewritten as
      follows:<a data-type="indexterm" data-primary="fields" data-secondary="field punning">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">magnitude</span> <span class="o">{</span> <span class="n">x</span><span class="o">;</span> <span class="o">y</span> <span class="o">}</span> <span class="o">=</span> <span class="o">s</span><span class="n">qrt</span> <span class="o">(</span><span class="n">x</span> <span class="o">**</span> <span class="o">2.</span> <span class="o">+.</span> <span class="o">y</span> <span class="o">**</span> <span class="o">2.);;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">magnitude</span> <span class="o">:</span> <span class="o">point2d</span> <span class="o">-&gt;</span> <span class="o">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>Alternatively, we can use dot notation for accessing
      record fields:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">distance</span> <span class="n">v1</span> <span class="n">v2</span> <span class="o">=</span>
    <span class="o">magnitude</span> <span class="o">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">x</span> <span class="o">-.</span> <span class="n">v2</span><span class="o">.</span><span class="n">x</span><span class="o">;</span> <span class="o">y</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.y</span> <span class="o">-.</span> <span class="n">v2</span><span class="o">.y</span> <span class="o">};;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">distance</span> <span class="o">:</span> <span class="o">point2d</span> <span class="o">-&gt;</span> <span class="o">point2d</span> <span class="o">-&gt;</span> <span class="o">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

      <p>And we can of course include our newly defined types as
      components in larger types. Here, for example, are some types
      for modeling different geometric objects that contain values
      of type <code>point2d</code>:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">type</span> <span class="o">circle_desc</span>  <span class="o">=</span> <span class="o">{</span> <span class="o">center:</span> <span class="o">point2d;</span> <span class="o">radius:</span> <span class="o">float</span> <span class="o">};;</span>
</pre><pre class="ge"><span></span><span class="k">type</span> <span class="o">circle_desc</span> <span class="o">=</span> <span class="o">{</span> <span class="o">center</span> <span class="o">:</span> <span class="o">point2d;</span> <span class="o">radius</span> <span class="o">:</span> <span class="o">float;</span> <span class="o">}</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">type</span> <span class="o">rect_desc</span>    <span class="o">=</span> <span class="o">{</span> <span class="o">lo</span><span class="n">wer_left</span><span class="o">:</span> <span class="o">point2d;</span> <span class="n">width</span><span class="o">:</span> <span class="o">float;</span> <span class="o">height:</span> <span class="o">float</span> <span class="o">};;</span>
</pre><pre class="ge"><span></span><span class="k">type</span> <span class="o">rect_desc</span> <span class="o">=</span> <span class="o">{</span> <span class="o">lo</span><span class="n">wer_left</span> <span class="o">:</span> <span class="o">point2d;</span> <span class="n">width</span> <span class="o">:</span> <span class="o">float;</span> <span class="o">height</span> <span class="o">:</span> <span class="o">float;</span> <span class="o">}</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">type</span> <span class="o">segment_desc</span> <span class="o">=</span> <span class="o">{</span> <span class="o">endpoint</span><span class="mi">1</span><span class="o">:</span> <span class="o">point2d;</span> <span class="o">endpoint2:</span> <span class="o">point2d</span> <span class="o">}</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">type</span> <span class="o">segment_desc</span> <span class="o">=</span> <span class="o">{</span> <span class="o">endpoint</span><span class="mi">1</span> <span class="o">:</span> <span class="o">point2d;</span> <span class="o">endpoint2</span> <span class="o">:</span> <span class="o">point2d;</span> <span class="o">}</span>
</pre></div>

      <p>Now, imagine that you want to combine multiple objects of
      these types together as a description of a multi-object scene.
      You need some unified way of representing these objects
      together in a single type. One way of doing this is using a
      <em>variant</em> type:<a data-type="indexterm" data-primary="datatypes" data-secondary="variant
      types">&nbsp;</a><a data-type="indexterm" data-primary="variant types" data-secondary="combining multiple object types
      with">&nbsp;</a></p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">type</span> <span class="o">scene_element</span> <span class="o">=</span>
    <span class="o">|</span> <span class="nc">Circle</span>  <span class="k">of</span> <span class="o">circle_desc</span>
    <span class="o">|</span> <span class="nc">Rect</span>    <span class="k">of</span> <span class="o">rect_desc</span>
    <span class="o">|</span> <span class="nc">Segment</span> <span class="k">of</span> <span class="o">segment_desc</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">type</span> <span class="o">scene_element</span> <span class="o">=</span>
    <span class="nc">Circle</span> <span class="k">of</span> <span class="o">circle_desc</span>
  <span class="o">|</span> <span class="nc">Rect</span> <span class="k">of</span> <span class="o">rect_desc</span>
  <span class="o">|</span> <span class="nc">Segment</span> <span class="k">of</span> <span class="o">segment_desc</span>
</pre></div>

      <p>The <code>|</code> character separates the different cases
      of the variant (the first <code>|</code> is optional), and
      each case has a capitalized tag, like <code>Circle</code>,
      <code>Rect</code> or <code>Segment</code>, to distinguish
      that case from the others.</p>

      <p>Here's how we might write a function for testing whether a
      point is in the interior of some element of a list of
      <code>scene_element</code>s:</p>
      <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">is_inside_scene_element</span> <span class="o">point</span> <span class="o">scene_element</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">scene_element</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Circle</span> <span class="o">{</span> <span class="o">center;</span> <span class="o">radius</span> <span class="o">}</span> <span class="o">-&gt;</span>
      <span class="o">distance</span> <span class="o">center</span> <span class="o">point</span> <span class="o">&lt;</span> <span class="o">radius</span>
    <span class="o">|</span> <span class="nc">Rect</span> <span class="o">{</span> <span class="o">lo</span><span class="n">wer_left</span><span class="o">;</span> <span class="n">width</span><span class="o">;</span> <span class="o">height</span> <span class="o">}</span> <span class="o">-&gt;</span>
      <span class="o">point.</span><span class="n">x</span>    <span class="o">&gt;</span> <span class="o">lo</span><span class="n">wer_left</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="o">point.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">lo</span><span class="n">wer_left</span><span class="o">.</span><span class="n">x</span> <span class="o">+.</span> <span class="n">width</span>
      <span class="o">&amp;&amp;</span> <span class="o">point.y</span> <span class="o">&gt;</span> <span class="o">lo</span><span class="n">wer_left</span><span class="o">.y</span> <span class="o">&amp;&amp;</span> <span class="o">point.y</span> <span class="o">&lt;</span> <span class="o">lo</span><span class="n">wer_left</span><span class="o">.y</span> <span class="o">+.</span> <span class="o">height</span>
    <span class="o">|</span> <span class="nc">Segment</span> <span class="o">{</span> <span class="o">endpoint</span><span class="mi">1</span><span class="o">;</span> <span class="o">endpoint2</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  
  <span class="k">let</span> <span class="o">is_inside_scene</span> <span class="o">point</span> <span class="o">scene</span> <span class="o">=</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="o">scene</span>
      <span class="o">~f:(</span><span class="k">fun</span> <span class="o">el</span> <span class="o">-&gt;</span> <span class="o">is_inside_scene_element</span> <span class="o">point</span> <span class="o">el)</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">is_inside_scene_element</span> <span class="o">:</span> <span class="o">point2d</span> <span class="o">-&gt;</span> <span class="o">scene_element</span> <span class="o">-&gt;</span> <span class="o">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="o">is_inside_scene</span> <span class="o">:</span> <span class="o">point2d</span> <span class="o">-&gt;</span> <span class="o">scene_element</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">is_inside_scene</span> <span class="o">{</span><span class="n">x</span><span class="o">=3.;y=7.}</span>
    <span class="o">[</span> <span class="nc">Circle</span> <span class="o">{center</span> <span class="o">=</span> <span class="o">{</span><span class="n">x</span><span class="o">=4.;y=</span> <span class="o">4.};</span> <span class="o">radius</span> <span class="o">=</span> <span class="o">0.5</span> <span class="o">}</span> <span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">bool</span> <span class="o">=</span> <span class="bp">false</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">is_inside_scene</span> <span class="o">{</span><span class="n">x</span><span class="o">=3.;y=7.}</span>
    <span class="o">[</span> <span class="nc">Circle</span> <span class="o">{center</span> <span class="o">=</span> <span class="o">{</span><span class="n">x</span><span class="o">=4.;y=</span> <span class="o">4.};</span> <span class="o">radius</span> <span class="o">=</span> <span class="o">5.0</span> <span class="o">}</span> <span class="o">];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div>

      <p>You might at this point notice that the use
      of <code>match</code> here is reminiscent of how we
      used <code>match</code> with <code>option</code>
      and <code>list</code>. This is no accident: <code>option</code>
      and <code>list</code> are just examples of variant types that
      are important enough to be defined in the standard library (and
      in the case of lists, to have some special syntax).</p>

      <p>We also made our first use of an <em>anonymous
      function</em> in the call to <code>List.exists</code>.
      Anonymous functions are declared using the <code>fun</code>
      keyword, and don't need to be explicitly named. Such
      functions are common in OCaml, particularly when using
      iteration functions like
      <code>List.exists</code>.<a data-type="indexterm" data-primary="anonymous
      functions">&nbsp;</a><a data-type="indexterm" data-primary="functions" data-secondary="anonymous functions">&nbsp;</a></p>

      <p>The purpose of <code>List.exists</code> is to check if there
      are any elements of the list in question for which the provided
      function evaluates to <code>true</code>. In this case, we're
      using <code>List.exists</code> to check if there is a scene
      element within which our point resides.</p>
    </section>

    <section id="imperative-programming" data-type="sect1">
      <h1>Imperative Programming</h1>

      <p>The code we've written so far has been almost entirely
      <em>pure</em> or <em>functional</em>, which roughly speaking
      means that the code in question doesn't modify variables or
      values as part of its execution. Indeed, almost all of the
      data structures we've encountered are <em>immutable</em>,
      meaning there's no way in the language to modify them at all.
      This is a quite different style from <em>imperative</em>
      programming, where computations are structured as sequences
      of instructions that operate by making modifications to the
      state of the program.<a data-type="indexterm" data-primary="functional code">&nbsp;</a><a data-type="indexterm" data-primary="pure
      code">&nbsp;</a><a data-type="indexterm" data-primary="data
      structures" data-secondary="immutable">&nbsp;</a><a data-type="indexterm" data-primary="programming" data-secondary="immutable vs.
      imperative">&nbsp;</a></p>

      <p>Functional code is the default in OCaml, with variable
      bindings and most data structures being immutable. But OCaml
      also has excellent support for imperative programming,
      including mutable data structures like arrays and hash
      tables, and control-flow constructs like <code>for</code> and
      <code>while</code> loops.</p>

      <section id="arrays" data-type="sect2">
        <h2>Arrays</h2>

        <p>Perhaps the simplest mutable data structure in OCaml is
        the array. Arrays in OCaml are very similar to arrays in
        other languages like C: indexing starts at 0, and accessing
        or modifying an array element is a constant-time operation.
        Arrays are more compact in terms of memory utilization than
        most other data structures in OCaml, including lists.
        Here's an example:<a data-type="indexterm" data-primary="data
        structures" data-secondary="arrays">&nbsp;</a><a data-type="indexterm" data-primary="arrays" data-secondary="imperative programming
        and">&nbsp;</a><a data-type="indexterm" data-primary="imperative programming" data-secondary="arrays">&nbsp;</a></p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">numbers</span> <span class="o">=</span> <span class="o">[|</span> <span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3;</span> <span class="o">4</span> <span class="o">|];;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">numbers</span> <span class="o">:</span> <span class="o">int</span> <span class="o">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3;</span> <span class="o">4|]</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">numbers.(2)</span> <span class="o">&lt;-</span> <span class="o">4;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">numbers;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">4;</span> <span class="o">4|]</span>
</pre></div>

        <p>The <code>.(i)</code> syntax is used to refer to an
        element of an array, and the <code>&lt;-</code> syntax is
        for modification. Because the elements of the array are
        counted starting at zero, element <span class="keep-together"><code>.(2)</code> is</span> the third
        element.</p>

        <p>The <code>unit</code> type that we see in the preceding
        code is interesting in that it has only one possible value,
        written <code>()</code>. This means that a value of type
        <code>unit</code> doesn't convey any information, and so is
        generally used as a placeholder. Thus, we use
        <code>unit</code> for the return value of an operation like
        setting a mutable field that communicates by side effect
        rather than by returning a value. It's also used as the
        argument to functions that don't require an input value.
        This is similar to the role that <code>void</code> plays in
        languages like C and Java.</p>
      </section>

      <section id="mutable-record-fields" data-type="sect2">
        <h2>Mutable Record Fields</h2>

        <p>The array is an important mutable data structure, but it's
        not the only one. Records, which are immutable by default, can
        have some of their fields explicitly declared as
        mutable. Here's an example of a mutable data structure for
        storing a running statistical summary of a collection of
        numbers.<a data-type="indexterm" data-primary="imperative programming" data-secondary="mutable record
        fields">&nbsp;</a><a data-type="indexterm" data-primary="mutable record fields">&nbsp;</a><a data-type="indexterm" data-primary="data
        structures" data-secondary="mutable record fields">&nbsp;</a></p> <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">type</span> <span class="o">running_sum</span> <span class="o">=</span>
    <span class="o">{</span> <span class="k">mutable</span> <span class="o">sum:</span> <span class="o">float;</span>
      <span class="k">mutable</span> <span class="o">sum_s</span><span class="n">q</span><span class="o">:</span> <span class="o">float;</span> <span class="c">(* sum of squares *)</span>
      <span class="k">mutable</span> <span class="o">samples:</span> <span class="o">int;</span>
    <span class="o">}</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">type</span> <span class="o">running_sum</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">mutable</span> <span class="o">sum</span> <span class="o">:</span> <span class="o">float;</span>
  <span class="k">mutable</span> <span class="o">sum_s</span><span class="n">q</span> <span class="o">:</span> <span class="o">float;</span>
  <span class="k">mutable</span> <span class="o">samples</span> <span class="o">:</span> <span class="o">int;</span>
<span class="o">}</span>
</pre></div>

        <p>The fields in <code>running_sum</code> are designed to
        be easy to extend incrementally, and sufficient to compute
        means and standard deviations, as shown in the following
        example. Note that there are two <code>let</code> bindings
        in a row without a double semicolon between them. That's
        because the double semicolon is required only to tell
        <em>utop</em> to process the input, not to separate two
        declarations:</p>

        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">mean</span> <span class="o">rsum</span> <span class="o">=</span> <span class="o">rsum.sum</span> <span class="o">/.</span> <span class="nn">Float</span><span class="p">.</span><span class="n">of_int</span> <span class="o">rsum.samples</span>
  <span class="k">let</span> <span class="o">stde</span><span class="n">v</span> <span class="o">rsum</span> <span class="o">=</span>
    <span class="o">s</span><span class="n">qrt</span> <span class="o">(rsum.sum_s</span><span class="n">q</span> <span class="o">/.</span> <span class="nn">Float</span><span class="p">.</span><span class="n">of_int</span> <span class="o">rsum.samples</span>
          <span class="o">-.</span> <span class="o">(rsum.sum</span> <span class="o">/.</span> <span class="nn">Float</span><span class="p">.</span><span class="n">of_int</span> <span class="o">rsum.samples)</span> <span class="o">**</span> <span class="o">2.)</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">mean</span> <span class="o">:</span> <span class="o">running_sum</span> <span class="o">-&gt;</span> <span class="o">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="o">stde</span><span class="n">v</span> <span class="o">:</span> <span class="o">running_sum</span> <span class="o">-&gt;</span> <span class="o">float</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>We use the function <code>float</code> above, which is a
        convenient equivalent of <code>Float.of_int</code> provided
        by the <code>Pervasives</code> library.</p>

        <p>We also need functions to create and update
        <code>running_sum</code>s:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">{</span> <span class="o">sum</span> <span class="o">=</span> <span class="o">0.;</span> <span class="o">sum_s</span><span class="n">q</span> <span class="o">=</span> <span class="o">0.;</span> <span class="o">samples</span> <span class="o">=</span> <span class="o">0</span> <span class="o">}</span>
  <span class="k">let</span> <span class="o">update</span> <span class="o">rsum</span> <span class="n">x</span> <span class="o">=</span>
    <span class="o">rsum.samples</span> <span class="o">&lt;-</span> <span class="o">rsum.samples</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">rsum.sum</span>     <span class="o">&lt;-</span> <span class="o">rsum.sum</span>     <span class="o">+.</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">rsum.sum_s</span><span class="n">q</span>  <span class="o">&lt;-</span> <span class="o">rsum.sum_s</span><span class="n">q</span>  <span class="o">+.</span> <span class="n">x</span> <span class="o">*.</span> <span class="n">x</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">create</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">-&gt;</span> <span class="o">running_sum</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="k">val</span> <span class="o">update</span> <span class="o">:</span> <span class="o">running_sum</span> <span class="o">-&gt;</span> <span class="o">float</span> <span class="o">-&gt;</span> <span class="o">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p><code>create</code> returns a <code>running_sum</code>
        corresponding to the empty set, and <code>update rsum
        x</code> changes <code>rsum</code> to reflect the addition
        of <code>x</code> to its set of samples by updating the
        number of samples, the sum, and the sum of squares.</p>

        <p>Note the use of single semicolons to sequence
        operations. When we were working purely functionally, this
        wasn't necessary, but you start needing it when you're
        writing imperative code.</p>

        <p>Here's an example of <code>create</code> and
        <code>update</code> in action. Note that this code uses
        <code>List.iter</code>, which calls the function
        <code>~f</code> on each element of the provided list:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">rsum</span> <span class="o">=</span> <span class="o">create</span> <span class="bp">()</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">rsum</span> <span class="o">:</span> <span class="o">running_sum</span> <span class="o">=</span> <span class="o">{sum</span> <span class="o">=</span> <span class="o">0.;</span> <span class="o">sum_s</span><span class="n">q</span> <span class="o">=</span> <span class="o">0.;</span> <span class="o">samples</span> <span class="o">=</span> <span class="o">0}</span>
</pre><pre><span></span><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">[</span><span class="mi">1</span><span class="o">.;3.;2.;-7.;4.;5.]</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">update</span> <span class="o">rsum</span> <span class="n">x</span><span class="o">);;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">mean</span> <span class="o">rsum;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">float</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.33333333333</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">stde</span><span class="n">v</span> <span class="o">rsum;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">float</span> <span class="o">=</span> <span class="o">3.944053</span><span class="mi">18873</span>
</pre></div>

        <p>It's worth noting that the preceding algorithm is
        numerically naive and has poor precision in the presence of
        cancellation. You can look at this Wikipedia <a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">
        article on algorithms for calculating variance</a> for more
        details, paying particular attention to the weighted
        incremental and parallel algorithms.</p>
      </section>

      <section id="refs" data-type="sect2">
        <h2>Refs</h2>

        <p>We can create a single mutable value by using a
        <code>ref</code>. The <code>ref</code> type comes
        predefined in the standard library, but there's nothing
        really special about it. It's just a record type with a
        single mutable field called
        <code>contents</code>:<a data-type="indexterm" data-primary="records" data-secondary="record
        types">&nbsp;</a><a data-type="indexterm" data-primary="imperative programming" data-secondary="ref type">&nbsp;</a></p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">{</span> <span class="o">contents</span> <span class="o">=</span> <span class="o">0</span> <span class="o">};;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">int</span> <span class="o">ref</span> <span class="o">=</span> <span class="o">{contents</span> <span class="o">=</span> <span class="o">0}</span>
</pre><pre><span></span><span class="o">#</span> <span class="n">x</span><span class="o">.contents</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="o">.contents</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre><pre><span></span><span class="o">#</span> <span class="n">x</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">ref</span> <span class="o">=</span> <span class="o">{contents</span> <span class="o">=</span> <span class="mi">1</span><span class="o">}</span>
</pre></div>

        <p>There are a handful of useful functions and operators
        defined for <code>ref</code>s to make them more convenient
        to work with:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">ref</span> <span class="o">0</span>  <span class="c">(* create a ref, i.e., { contents = 0 } *)</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">int</span> <span class="o">ref</span> <span class="o">=</span> <span class="o">{contents</span> <span class="o">=</span> <span class="o">0}</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">!</span><span class="n">x</span>             <span class="c">(* get the contents of a ref, i.e., x.contents *)</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">0</span>
</pre><pre><span></span><span class="o">#</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>    <span class="c">(* assignment, i.e., x.contents &lt;- ... *)</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">!</span><span class="n">x</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>

        <p>There's nothing magical with these operators either. You
        can completely reimplement the <code>ref</code> type and
        all of these operators in just a few lines of code:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">type</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">ref</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="o">contents</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">};;</span>
</pre><pre class="ge"><span></span><span class="k">type</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">ref</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="o">contents</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a;</span> <span class="o">}</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">ref</span> <span class="n">x</span> <span class="o">=</span> <span class="o">{</span> <span class="o">contents</span> <span class="o">=</span> <span class="n">x</span> <span class="o">};;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">ref</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">ref</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">(!)</span> <span class="o">r</span> <span class="o">=</span> <span class="o">r.contents;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">(</span> <span class="o">!</span> <span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">ref</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">(:=)</span> <span class="o">r</span> <span class="n">x</span> <span class="o">=</span> <span class="o">r.contents</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">(</span> <span class="o">:=</span> <span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">ref</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="o">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>The <code>'a</code> before the <code>ref</code>
        indicates that the <code>ref</code> type is polymorphic, in
        the same way that lists are polymorphic, meaning it can
        contain values of any type. The parentheses around
        <code>!</code> and <code>:=</code> are needed because these
        are operators, rather than ordinary
        functions.<a data-type="indexterm" data-primary="parametric polymorphism">&nbsp;</a></p>

        <p>Even though a <code>ref</code> is just another record
        type, it's important because it is the standard way of
        simulating the traditional mutable variables you'll find in
        most languages. For example, we can sum over the elements
        of a list imperatively by calling <code>List.iter</code> to
        call a simple function on every element of a list, using a
        <code>ref</code> to accumulate the results:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">sum</span> <span class="o">list</span> <span class="o">=</span>
    <span class="k">let</span> <span class="o">sum</span> <span class="o">=</span> <span class="o">ref</span> <span class="o">0</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">list</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">sum</span> <span class="o">:=</span> <span class="o">!sum</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span>
    <span class="o">!sum</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">sum</span> <span class="o">:</span> <span class="o">int</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>This isn't the most idiomatic way to sum up a list, but
        it shows how you can use a <code>ref</code> in place of a
        mutable variable.</p>
      </section>

      <section id="for-and-while-loops" data-type="sect2">
        <h2>For and While Loops</h2>

        <p>OCaml also supports traditional imperative control-flow
        constructs like <code>for and while</code> loops. Here, for
        example, is some code for permuting an array that uses a
        <code>for</code> loop. We use the <code>Random</code>
        module as our source of randomness. <code>Random</code>
        starts with a default seed, but you can call
        <code>Random.self_init</code> to choose a new seed at
        random:<a data-type="indexterm" data-primary="Random module">&nbsp;</a><a data-type="indexterm" data-primary="while
        loops">&nbsp;</a><a data-type="indexterm" data-primary="for loops">&nbsp;</a><a data-type="indexterm" data-primary="imperative
        programming" data-secondary="for and while loops">&nbsp;</a></p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">permute</span> <span class="o">array</span> <span class="o">=</span>
    <span class="k">let</span> <span class="o">length</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="o">array</span> <span class="k">in</span>
    <span class="k">for</span> <span class="o">i</span> <span class="o">=</span> <span class="o">0</span> <span class="k">to</span> <span class="o">length</span> <span class="o">-</span> <span class="o">2</span> <span class="k">do</span>
      <span class="c">(* pick a j to swap with *)</span>
      <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="o">i</span> <span class="o">+</span> <span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="o">(length</span> <span class="o">-</span> <span class="o">i)</span> <span class="k">in</span>
      <span class="c">(* Swap i and j *)</span>
      <span class="k">let</span> <span class="o">tmp</span> <span class="o">=</span> <span class="o">array.(i)</span> <span class="k">in</span>
      <span class="o">array.(i)</span> <span class="o">&lt;-</span> <span class="o">array.(</span><span class="n">j</span><span class="o">);</span>
      <span class="o">array.(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="o">tmp</span>
    <span class="k">done</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">permute</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">array</span> <span class="o">-&gt;</span> <span class="o">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

        <p>From a syntactic perspective, you should note the
        keywords that distinguish a <code>for</code> loop:
        <code>for</code>, <code>to</code>, <code>do</code>, and
        <code>done</code>.</p>

        <p>Here's an example run of this code:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">ar</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="o">20</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="o">i</span> <span class="o">-&gt;</span> <span class="o">i);;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">ar</span> <span class="o">:</span> <span class="o">int</span> <span class="o">array</span> <span class="o">=</span>
  <span class="o">[|0;</span> <span class="mi">1</span><span class="o">;</span> <span class="o">2;</span> <span class="o">3;</span> <span class="o">4;</span> <span class="o">5;</span> <span class="o">6;</span> <span class="o">7;</span> <span class="o">8;</span> <span class="o">9;</span> <span class="mi">10</span><span class="o">;</span> <span class="mi">11</span><span class="o">;</span> <span class="mi">12</span><span class="o">;</span> <span class="mi">13</span><span class="o">;</span> <span class="mi">14</span><span class="o">;</span> <span class="mi">15</span><span class="o">;</span> <span class="mi">16</span><span class="o">;</span> <span class="mi">17</span><span class="o">;</span> <span class="mi">18</span><span class="o">;</span> <span class="mi">19</span><span class="o">|]</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">permute</span> <span class="o">ar;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">ar;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">array</span> <span class="o">=</span>
<span class="o">[|6;</span> <span class="o">0;</span> <span class="o">7;</span> <span class="mi">17</span><span class="o">;</span> <span class="o">2;</span> <span class="mi">11</span><span class="o">;</span> <span class="o">8;</span> <span class="mi">19</span><span class="o">;</span> <span class="o">5;</span> <span class="mi">1</span><span class="o">;</span> <span class="o">3;</span> <span class="mi">16</span><span class="o">;</span> <span class="mi">12</span><span class="o">;</span> <span class="mi">18</span><span class="o">;</span> <span class="mi">13</span><span class="o">;</span> <span class="mi">10</span><span class="o">;</span> <span class="mi">15</span><span class="o">;</span> <span class="mi">14</span><span class="o">;</span> <span class="o">9;</span> <span class="o">4|]</span>
</pre></div>

        <p>OCaml also supports <code>while</code> loops, as shown
        in the following function for finding the position of the
        first negative entry in an array. Note that
        <code>while</code> (like <code>for</code>) is also a
        keyword:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">find_first_negati</span><span class="n">ve_entry</span> <span class="o">array</span> <span class="o">=</span>
    <span class="k">let</span> <span class="o">pos</span> <span class="o">=</span> <span class="o">ref</span> <span class="o">0</span> <span class="k">in</span>
    <span class="k">while</span> <span class="o">!pos</span> <span class="o">&lt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="o">array</span> <span class="o">&amp;&amp;</span> <span class="o">array.(!pos)</span> <span class="o">&gt;=</span> <span class="o">0</span> <span class="k">do</span>
      <span class="o">pos</span> <span class="o">:=</span> <span class="o">!pos</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">done</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">!pos</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="o">array</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span> <span class="o">!pos</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">find_first_negati</span><span class="n">ve_entry</span> <span class="o">:</span> <span class="o">int</span> <span class="o">array</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">find_first_negati</span><span class="n">ve_entry</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;2;0;3|];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">option</span> <span class="o">=</span> <span class="nc">None</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">find_first_negati</span><span class="n">ve_entry</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;-2;0;3|];;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">int</span> <span class="o">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">1</span>
</pre></div>

        <p>As a side note, the preceding code takes advantage of
        the fact that <code>&amp;&amp;</code>, OCaml's And
        operator, short-circuits. In particular, in an expression
        of the form <em><code>expr1</code></em>
        <code>&amp;&amp;</code> <em><code>expr2</code></em>,
        <em><code>expr2</code></em> will only be evaluated if
        <em><code>expr1</code></em> evaluated to true. Were it not
        for that, then the preceding function would result in an
        out-of-bounds error. Indeed, we can trigger that
        out-of-bounds error by rewriting the function to avoid the
        short-circuiting:</p>
        <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">find_first_negati</span><span class="n">ve_entry</span> <span class="o">array</span> <span class="o">=</span>
    <span class="k">let</span> <span class="o">pos</span> <span class="o">=</span> <span class="o">ref</span> <span class="o">0</span> <span class="k">in</span>
    <span class="k">while</span>
      <span class="k">let</span> <span class="o">pos_is_good</span> <span class="o">=</span> <span class="o">!pos</span> <span class="o">&lt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="o">array</span> <span class="k">in</span>
      <span class="k">let</span> <span class="o">element_is_non_negati</span><span class="n">ve</span> <span class="o">=</span> <span class="o">array.(!pos)</span> <span class="o">&gt;=</span> <span class="o">0</span> <span class="k">in</span>
      <span class="o">pos_is_good</span> <span class="o">&amp;&amp;</span> <span class="o">element_is_non_negati</span><span class="n">ve</span>
    <span class="k">do</span>
      <span class="o">pos</span> <span class="o">:=</span> <span class="o">!pos</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">done</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">!pos</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="o">array</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span> <span class="o">!pos</span>
  <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">find_first_negati</span><span class="n">ve_entry</span> <span class="o">:</span> <span class="o">int</span> <span class="o">array</span> <span class="o">-&gt;</span> <span class="o">int</span> <span class="o">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">find_first_negati</span><span class="n">ve_entry</span> <span class="o">[|</span><span class="mi">1</span><span class="o">;2;0;3|];;</span>
</pre><pre class="ge">Exception: (Invalid_argument "index out of bounds").</pre></div>

        <p>The or operator, <code>||</code>, short-circuits in a
        similar way to <code>&amp;&amp;</code>.</p>
      </section>
    </section>

    <section id="a-complete-program" data-type="sect1">
      <h1>A Complete Program</h1>

      <p>So far, we've played with the basic features of the
      language via <span class="command"><em>utop</em></span>. Now
      we'll show how to create a simple standalone program. In
      particular, we'll create a program that sums up a list of
      numbers read in from the standard
      input.<a data-type="indexterm" data-primary="programming" data-secondary="simple standalone example">&nbsp;</a></p>

      <p>Here's the code, which you can save in a file called
      <em class="filename">sum.ml</em>. Note that we don't
      terminate expressions with <code>;;</code> here, since it's
      not required outside the toplevel:</p>
      <div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Core_kernel</span>

<span class="k">let</span> <span class="k">rec</span> <span class="o">read_and_accumulate</span> <span class="o">accum</span> <span class="o">=</span>
  <span class="k">let</span> <span class="o">line</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">input_line</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">stdin</span> <span class="k">in</span>
  <span class="k">match</span> <span class="o">line</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="o">accum</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">read_and_accumulate</span> <span class="o">(accum</span> <span class="o">+.</span> <span class="nn">Float</span><span class="p">.</span><span class="n">of_string</span> <span class="n">x</span><span class="o">)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="o">printf</span> <span class="s2">&quot;Total: %F</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(read_and_accumulate</span> <span class="o">0.)</span>
</pre></div>

      <p>This is our first use of OCaml's input and output
      routines. The function <code>read_and_accumulate</code> is a
      recursive function that uses
      <code>In_channel.input_line</code> to read in lines one by
      one from the standard input, invoking itself at each
      iteration with its updated accumulated sum. Note that
      <code>input_line</code> returns an optional value, with
      <code>None</code> indicating the end of the input stream.</p>

      <p>After <code>read_and_accumulate</code> returns, the total
      needs to be printed. This is done using the <code>printf</code>
      command, which provides support for type-safe format strings,
      similar to what you'll find in a variety of languages. The
      format string is parsed by the compiler and used to determine
      the number and type of the remaining arguments that
      are <span class="keep-together">required</span>. In this case,
      there is a single formatting directive, <code>%F</code>,
      so <code>printf</code> expects one additional argument of
      type <code>float</code>.</p>

      <section id="compiling-and-running" data-type="sect2">
        <h2>Compiling and Running</h2>

        <p>We'll compile our program
        using <span class="command"><em>jbuilder</em></span>, a build
        system that's designed for use with OCaml projects. First, we
        need to write a <em>jbuild</em> file to specify the build.</p>
        <div class="highlight"><pre>(jbuild_version 1)

(executables
 ((names (sum))
  (libraries (core_kernel))
  ))
</pre></div>

	<p>All we need to specify is the fact that we're building an
	executable rather than a library, the name of the executable,
	and the name of the libraries we depend on.</p>
	
	<p>We can now invoke jbuilder to build the executable.
	The <code>--dev</code> flag is recommended to get better error
	messages during the build.</p>
        <div class="highlight"><pre>$ jbuilder build sum.exe --dev
    ocamldep sum.depends.ocamldep-output
      ocamlc sum.{cmi,cmo,cmt}
    ocamlopt sum.{cmx,o}
    ocamlopt sum.exe
</pre></div>

        <p>The <code>.exe</code> suffix indicates that we're building
        a native-code executable, which we'll discuss more
        in <a href="04-files-modules-and-programs.html#files-modules-and-programs" data-type="xref">Chapter 4, Files Modules And Programs</a>. Once the
        build completes, we can use the resulting program like any
        command-line utility. We can feed input
        to <code>sum.native</code> by typing in a sequence of numbers,
        one per line, hitting <strong><code>Ctrl-D</code></strong>
        when we're done:</p> <div class="highlight"><pre>$ ./_build/default/sum.exe
1
2
3
94.5
Total: 100.5
</pre></div>

        <p>More work is needed to make a really usable command-line
        program, including a proper command-line parsing interface and
        better error handling, all of which is covered
        in <a href="14-command-line-parsing.html#command-line-parsing" data-type="xref">Chapter 14, Command Line Parsing</a>.</p>
      </section>
    </section>

    <section id="where-to-go-from-here" data-type="sect1">
      <h1>Where to Go from Here</h1>

      <p>That's it for the guided tour! There are plenty of
      features left and lots of details to explain, but we hope
      that you now have a sense of what to expect from OCaml, and
      that you'll be more comfortable reading the rest of the book
      as a result.</p>
    </section>
  </section>
</article></div><a class="next-chapter" href="02-variables-and-functions.html"><div class="content"><h1><small>Next: Chapter 02</small>Variables and Functions</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://plus.google.com/111219778721183890368">+hickey</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2014 Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script><script src="js/discourse.js"></script></body></html>