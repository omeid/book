<html class="js flexbox fontface" lang="en" style=""><head><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Real World OCaml</title><link rel="stylesheet" href="css/app.css"/><script src="js/min/modernizr-min.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a href="toc.html" class="to-chapter"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body">
  <section xmlns="http://www.w3.org/1999/xhtml" id="prologue" data-type="chapter">
    <h1>Prologue</h1>

    <section id="why-ocaml" data-type="sect1">
      <h1>Why OCaml?</h1>

      <p>Programming languages matter. They affect the reliability,
      security, and efficiency of the code you write, as well as
      how easy it is to read, refactor, and extend. The languages
      you know can also change how you think, influencing the way
      you design software even when you're not using them.</p>

      <p>We wrote this book because we believe in the importance of
      programming languages, and that OCaml in particular is an
      important language to learn. The three of us have been using
      OCaml in our academic and professional lives for over 15
      years, and in that time we've come to see it as a secret
      weapon for building complex software systems. This book aims
      to make this secret weapon available to a wider audience, by
      providing a clear guide to what you need to know to use OCaml
      effectively in the real world.</p>

      <p>What makes OCaml special is that it occupies a sweet spot in
      the space of programming language designs. It provides a
      combination of efficiency, expressiveness and practicality that
      is matched by no other language. That is in large part because
      OCaml is an elegant combination of a set of language features
      that have been developed over the last 40 years. These include:

	<a data-type="indexterm" data-primary="OCaml" data-secondary="key features of">&nbsp;</a> </p>

      <ul>
        <li>
          <p><em>Garbage collection</em> for automatic memory
          management, now a feature of almost every modern,
          high-level language.</p>
        </li>

        <li>
          <p><em>First-class functions</em> that can be passed
          around like ordinary values, as seen in JavaScript,
          Common Lisp, and C#.</p>
        </li>

        <li>
          <p><em>Static type-checking</em> to increase performance
          and reduce the number of runtime errors, as found in Java
          and C#.</p>
        </li>

        <li>
          <p><em>Parametric polymorphism</em>, which enables the
          construction of abstractions that work across different
          data types, similar to generics in Java and C# and
          templates in <span class="keep-together">C++.</span></p>
        </li>

        <li>
          <p>Good support for <em>immutable
          programming</em>, <em>i.e.</em>, programming without making
          destructive updates to data structures. This is present in
          traditional
          functional <span class="keep-together">languages</span> like
          Scheme, and is also found in distributed, big-data
          frameworks like Hadoop.</p>
        </li>

        <li> <p>
	    <em>Type inference</em>, so you don't need to annotate
	    every single variable in your program with its type.
	    Instead, types are inferred based on how a value is used.
	    Available in a limited form in C# with implicitly typed
	    local variables, and in C++11 with its <code>auto</code>
	    keyword.</p>
        </li>

        <li>
          <p><em>Algebraic data types</em> and <em>pattern
          matching</em> to define and manipulate complex data
          structures. Available in Scala and F#.</p>
        </li>
      </ul>

      <p>Some of you will know and love all of these features, and for
      others they'll be largely new, but most of you will have seen
      some of them in other languages that you've used. As we'll
      demonstrate over the course of this book, there is something
      transformative about having all these features together and able
      to interact in a single language. Despite their importance,
      these ideas have made only limited inroads into mainstream
      languages, and when they do arrive there, like first-class
      functions in C# or parametric polymorphism in Java, it's
      typically in a limited and awkward form. The only languages that
      completely embody these ideas are <em>statically typed,
      functional programming languages</em> like OCaml, F#, Haskell,
      Scala, and Standard ML.<a data-type="indexterm" data-primary="OCaml" data-secondary="benefits of">&nbsp;</a></p>

      <p>Among this worthy set of languages, OCaml stands apart
      because it manages to provide a great deal of power while
      remaining highly pragmatic. The compiler has a
      straightforward compilation strategy that produces performant
      code without requiring heavy optimization and without the
      complexities of dynamic just-in-time (JIT) compilation. This,
      along with OCaml's strict evaluation model, makes runtime
      behavior easy to predict. The garbage collector is
      <em>incremental</em>, letting you avoid large garbage
      collection (GC)-related pauses, and <em>precise</em>, meaning
      it will collect all unreferenced data (unlike many
      reference-counting collectors), and the runtime is simple and
      highly portable.</p>

      <p>All of this makes OCaml a great choice for programmers who
      want to step up to a better programming language, and at the
      same time get practical work done.</p>

      <section id="a-brief-history" data-type="sect2">
        <h2>A Brief History</h2>

        <p>OCaml was written in 1996 by Xavier Leroy, Jérôme
        Vouillon, Damien Doligez, and Didier Rémy at INRIA in
        France. It was inspired by a long line of research into ML
        starting in the 1960s, and continues to have deep links to
        the academic community.<a data-type="indexterm" data-primary="OCaml" data-secondary="history of">&nbsp;</a></p>

        <p>ML was originally the <em>meta language</em> of the LCF
        (Logic for Computable Functions) proof assistant released
        by Robin Milner in 1972 (at Stanford, and later at
        Cambridge). ML was turned into a compiler in order to make
        it easier to use LCF on different machines, and it was
        gradually turned into a full-fledged system of its own by
        the 1980s.</p>

        <p>The first implementation of Caml appeared in 1987. It
        was created by Ascánder Suárez and later continued by
        Pierre Weis and Michel Mauny. In 1990, Xavier Leroy and
        Damien Doligez built a new implementation called Caml Light
        that was based on a bytecode interpreter with a fast,
        sequential garbage collector. Over the next few years
        useful libraries appeared, such as Michel Mauny's syntax
        manipulation tools, and this helped promote the use of Caml
        in education and research teams.</p>

        <p>Xavier Leroy continued extending Caml Light with new
        features, which resulted in the 1995 release of Caml
        Special Light. This improved the executable efficiency
        significantly by adding a fast native code compiler that
        made Caml's performance competitive with mainstream
        languages such as C++. A module system inspired by Standard
        ML also provided powerful facilities for abstraction and
        made larger-scale programs easier to construct.</p>

        <p>The modern OCaml emerged in 1996, when a powerful and
        elegant object system was implemented by Didier Rémy and
        Jérôme Vouillon. This object system was notable for
        supporting many common object-oriented idioms in a
        statically type-safe way, whereas the same idioms required
        runtime checks in languages such as C++ or Java. In 2000,
        Jacques Garrigue extended OCaml with several new features
        such as polymorphic methods, variants, and labeled and
        optional arguments.</p>

        <p>The last decade has seen OCaml attract a significant
        user base, and language improvements have been steadily
        added to support the growing commercial and academic
        <span class="keep-together">codebases</span>. First-class
        modules, Generalized Algebraic Data Types (GADTs), and
        dynamic linking have improved the flexibility of the
        language. There is also fast native code support for
        x86_64, ARM, PowerPC, and Sparc, making OCaml a good choice
        for systems where resource usage, predictability, and
        performance all matter.</p>
      </section>

      <section id="the-core-standard-library" data-type="sect2">
        <h2>The <code>Core</code> Standard Library</h2>

        <p>A language on its own isn't enough. You also need a rich
        set of libraries to base your applications on. A common
        source of frustration for those learning OCaml is that the
        standard library that ships with the compiler is limited,
        covering only a small subset of the functionality you would
        expect from a general-purpose standard library. That's
        because the standard library isn't a general-purpose tool;
        it was developed for use in bootstrapping the compiler and
        is purposefully kept small and simple.<a data-type="indexterm" data-primary="Core standard
        library" data-secondary="development of">&nbsp;</a><a data-type="indexterm" data-primary="OCaml" data-secondary="Core standard
        library">&nbsp;</a></p>

        <p>Happily, in the world of open source software, nothing
        stops alternative libraries from being written to
        supplement the compiler-supplied standard library, and this
        is exactly what <code>Core</code> is.</p>

        <p>Jane Street, a company that has been using OCaml for
        more than a decade, developed <code>Core</code> for its own
        internal use, but designed it from the start with an eye
        toward being a general-purpose standard library. Like the
        OCaml language itself, <code>Core</code> is engineered with
        correctness, reliability, and performance in mind.</p>

        <p><code>Core</code> is distributed with syntax extensions
        that provide useful new functionality to OCaml, and there
        are additional libraries such as the <code>Async</code>
        network communications library that extend the reach of
        <code>Core</code> into building complex distributed
        systems. All of these libraries are distributed under a
        liberal Apache 2 license to permit free use in hobby,
        academic, and commercial settings.</p>
      </section>

      <section id="the-ocaml-platform" data-type="sect2">
        <h2>The OCaml Platform</h2>

        <p><code>Core</code> is a comprehensive and effective
        standard library, but there's much more OCaml software out
        there. A large community of programmers has been using
        OCaml since its first release in 1996, and has generated
        many useful libraries and tools. We'll introduce some of
        these libraries in the course of the examples presented in
        the book.<a data-type="indexterm" data-primary="OCaml" data-secondary="third-party libraries for">&nbsp;</a></p>

        <p>The installation and management of these third-party
        libraries is made much easier via a package management tool
        known as <a href="http://opam.ocaml.org/">OPAM</a>. We'll
        explain more about OPAM as the book unfolds, but it forms
        the basis of the Platform, which is a set of tools and
        libraries that, along with the OCaml compiler, lets you
        build real-world applications quickly and effectively.</p>

        <p>We'll also use OPAM for installing the <span class="command"><em>utop</em></span> command-line interface. This
        is a modern interactive tool that supports command history,
        macro expansion, module completion, and other niceties that
        make it much more pleasant to work with the language. We'll
        be using <span class="command"><em>utop</em></span>
        throughout the book to let you step through the examples
        interactively.</p>
      </section>
    </section>

    <section id="about-this-book" data-type="sect1">
      <h1>About This Book</h1>

      <p><em>Real World OCaml</em> is aimed at programmers who have
      some experience with conventional programming languages, but
      not specifically with statically typed functional
      programming. Depending on your background, many of the
      concepts we cover will be new, including traditional
      functional-programming techniques like higher-order functions
      and immutable data types, as well as aspects of OCaml's
      powerful type and module systems.</p>

      <p>If you already know OCaml, this book may surprise you.
      Core redefines most of the standard namespace to make better
      use of the OCaml module system and expose a number of
      powerful, reusable data structures by default. Older OCaml
      code will still interoperate with Core, but you may need to
      adapt it for maximal benefit. All the new code that we write
      uses Core, and we believe the Core model is worth learning;
      it's been successfully used on large, multimillion-line
      codebases and removes a big barrier to building sophisticated
      applications in OCaml.</p>

      <p>Code that uses only the traditional compiler standard
      library will always exist, but there are other online
      resources for learning how that works. <em>Real World
      OCaml</em> focuses on the techniques the authors have used in
      their personal experience to construct scalable, robust
      software systems.</p>

      <section id="what-to-expect" data-type="sect2">
        <h2>What to Expect</h2>

        <p><em>Real World OCaml</em> is split into three parts:</p>

        <ul>
          <li>
            <p>Part I covers the language itself, opening with a
            guided tour designed to provide a quick sketch of the
            language. Don't expect to understand everything in the
            tour; it's meant to give you a taste of many different
            aspects of the language, but the ideas covered there
            will be explained in more depth in the chapters that
            follow.</p>

            <p>After covering the core language, Part I then moves
            onto more advanced features like modules, functors, and
            objects, which may take some time to digest.
            Understanding these concepts is important, though.
            These ideas will put you in good stead even beyond
            OCaml when switching to other modern languages, many of
            which have drawn inspiration from ML.</p>
          </li>

          <li>
            <p>Part II builds on the basics by working through
            useful tools and techniques for addressing common
            practical applications, from command-line parsing to
            asynchronous network programming. Along the way, you'll
            see how some of the <span class="keep-together">concepts</span> from Part I are glued
            together into real libraries and tools that combine
            different features of the language to good effect.</p>
          </li>

          <li>
            <p>Part III discusses OCaml's runtime system and
            compiler toolchain. It is remarkably simple when
            compared to some other language implementations (such
            as Java's or .NET's CLR). Reading this part will enable
            you to build very-high-performance systems, or to
            interface with C libraries. This is also where we talk
            about profiling and debugging techniques using tools
            such as GNU <span class="command"><em>gdb</em></span>.</p>
          </li>
        </ul>
      </section>

      <section id="installation-instructions" data-type="sect2">
        <h2>Installation Instructions</h2>

        <p><em>Real World OCaml</em> uses some tools that we've
        developed while writing this book. Some of these resulted
        in improvements to the OCaml compiler, which means that you
        will need to ensure that you have an up-to-date development
        environment (using the 4.02.1 version of the compiler). The
        installation process is largely automated through the OPAM
        package manager. Instructions on how to it set up and what
        packages to install can be found at <a href="http://realworldocaml.org/install">this Real World OCaml
        page</a>.<a data-type="indexterm" data-primary="installation
        instructions">&nbsp;</a><a data-type="indexterm" data-primary="OCaml" data-secondary="installation
        instructions">&nbsp;</a></p>

        <p><code>Core</code> requires a UNIX based operating
        system, and so only works on systems like Mac OS X, Linux,
        FreeBSD, and OpenBSD. Core includes a portable subset
        called <code>Core_kernel</code> which works anywhere OCaml
        is, and in particular works on Windows and Javascript. The
        examples in Part I of the book will only use
        <code>Core_kernel</code> and other highly portable
        libraries.</p><a data-type="indexterm" data-primary="OCaml" data-secondary="operating system support">&nbsp;</a>

        <p>This book is not intended as a reference manual. We aim
        to teach you about the language and about libraries tools
        and techniques that will help you be a more effective OCaml
        programmer. But it's no replacement for API documentation
        or the OCaml manual and man pages. You can find
        documentation for all of the libraries and tools referenced
        in the book <a href="https://realworldocaml.org/doc">online</a>.</p>
      </section>

      <section id="code-examples" data-type="sect2">
        <h2>Code Examples</h2>

        <p>All of the code examples in this book are available
        freely online under a public-domain-like license. You are
        most welcome to copy and use any of the snippets as you see
        fit in your own code, without any attribution or other
        restrictions on their use.<a data-type="indexterm" data-primary="OCaml" data-secondary="code examples
        for">&nbsp;</a></p>

        <p>The code repository is available online at <a href="https://github.com/realworldocaml/examples"><em class="hyperlink">https://github.com/realworldocaml/examples</em></a>.
        Every code snippet in the book has a clickable header that
        tells you the filename in that repository to find the
        source code, shell script, or ancillary data file that the
        snippet was sourced from.</p>

        <p>If you feel your use of code examples falls outside fair
        use or the permission given above, feel free to contact us
        at <a class="email" href="mailto:permissions@oreilly.com"><em>permissions@oreilly.com</em></a>.</p>
      </section>
    </section>

    <section id="safari-books-online" data-type="sect1">
      <h1>Safari® Books Online</h1>

      <div class="safarienabled">
        <p>Safari Books Online (<a href="http://my.safaribooksonline.com/?portal=oreilly" class="orm:hideurl:ital"><em class="hyperlink">www.safaribooksonline.com</em></a>) is an
        on-demand digital library that delivers expert <a href="http://www.safaribooksonline.com/content" class="orm:hideurl">content</a> in both book and video form from
        the world’s leading authors in technology and business.
        Technology professionals, software developers, web
        designers, and business and creative professionals use
        Safari Books Online as their primary resource for research,
        problem solving, learning, and certification training.</p>
      </div>

      <p>Safari Books Online offers a range of <a href="http://www.safaribooksonline.com/subscriptions" class="orm:hideurl">product mixes</a> and pricing programs for
      <a href="http://www.safaribooksonline.com/organizations-teams" class="orm:hideurl">organizations</a>, <a href="http://www.safaribooksonline.com/government" class="orm:hideurl">government agencies</a>, and <a href="http://www.safaribooksonline.com/individuals" class="orm:hideurl">individuals</a>. Subscribers have access to
      thousands of books, training videos, and prepublication
      manuscripts in one fully searchable database from publishers
      like O’Reilly Media, Prentice Hall Professional,
      Addison-Wesley Professional, Microsoft Press, Sams, Que,
      Peachpit Press, Focal Press, Cisco Press, John Wiley &amp;
      Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe
      Press, FT Press, Apress, Manning, New Riders, McGraw-Hill,
      Jones &amp; Bartlett, Course Technology, and dozens <a href="http://www.safaribooksonline.com/publishers" class="orm:hideurl">more</a>. For more information about Safari
      Books Online, please visit us <a href="http://www.safaribooksonline.com/" class="orm:hideurl">online</a>.</p>
    </section>

    <section id="how-to-contact-us" data-type="sect1">
      <h1>How to Contact Us</h1>

      <p>Please address comments and questions concerning this book
      to the publisher:</p>

      <ul class="simplelist">
        <li>O’Reilly Media, Inc.</li>

        <li>1005 Gravenstein Highway North</li>

        <li>Sebastopol, CA 95472</li>

        <li>800-998-9938 (in the United States or Canada)</li>

        <li>707-829-0515 (international or local)</li>

        <li>707-829-0104 (fax)</li>
      </ul>

      <p>We have a web page for this book, where we list errata,
      examples, and any additional information. You can access this
      page at:</p>

      <ul class="simplelist">
        <li>
          <a href="http://oreil.ly/realworldOCaml"><em class="hyperlink">http://oreil.ly/realworldOCaml</em></a>
        </li>
      </ul>

      <p>To comment or ask technical questions about this book,
      send email to:</p>

      <ul class="simplelist">
        <li>
          <a class="email" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a>
        </li>
      </ul>

      <p>For more information about our books, courses,
      conferences, and news, see our website at <a href="http://www.oreilly.com"><em class="hyperlink">http://www.oreilly.com</em></a>.</p>

      <p>Find us on Facebook: <a href="http://facebook.com/oreilly"><em class="hyperlink">http://facebook.com/oreilly</em></a></p>

      <p>Follow us on Twitter: <a href="http://twitter.com/oreillymedia"><em class="hyperlink">http://twitter.com/oreillymedia</em></a></p>

      <p>Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia"><em class="hyperlink">http://www.youtube.com/oreillymedia</em></a></p>
    </section>

    <section id="contributors" data-type="sect1">
      <h1>Contributors</h1>

      <p>We would especially like to thank the following
      individuals for improving <em>Real World OCaml</em>:</p>

      <ul>
        <li>
          <p>Leo White contributed greatly to the content and
          examples in <a href="11-objects.html#objects" data-type="xref">Chapter 11, Objects</a> and <a href="12-classes.html#classes" data-type="xref">Chapter 12, Classes</a>.</p>
        </li>

        <li>
          <p>Jeremy Yallop authored and documented the Ctypes
          library described in <a href="19-foreign-function-interface.html#foreign-function-interface" data-type="xref">Chapter 19, Foreign Function Interface</a>.</p>
        </li>

        <li>
          <p>Stephen Weeks is responsible for much of the modular
          architecture behind Core, and his extensive notes formed
          the basis of <a href="20-runtime-memory-layout.html#memory-representation-of-values" data-type="xref">Chapter 20, Memory Representation Of Values</a> and
          <a href="21-garbage-collector.html#understanding-the-garbage-collector" data-type="xref">Chapter 21, Understanding The Garbage
          Collector</a>.</p>
        </li>

        <li>
          <p>
	    Jérémie Dimino, the author of <em>utop</em>, the
            interactive command-line interface that is used
            throughout this book. We're particularly grateful for the
            changes that he pushed through to make <em>utop</em> work
            better in the context of the book.</p>
        </li>

        <li>
          <p>
	    Ashish Agarwal and Christoph Troestler worked on improving
	    the book's toolchain.  This allowed us to update the book
	    to track changes to OCaml and various libraries and tools.
	    Ashish also developed a new and improved version of the
	    book's website.</p>
        </li>

        <li>
          <p>
	    The many people who collectively submitted over 2400
            comments to online drafts of this book, through whose
            efforts countless errors were found and fixed.</p>
        </li>
      </ul>
    </section>
  </section>
</article></div><a class="next-chapter" href="01-guided-tour.html"><div class="content"><h1><small>Next: Chapter 01</small>A Guided Tour</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://plus.google.com/111219778721183890368">+hickey</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2014 Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script><script src="js/discourse.js"></script></body></html>