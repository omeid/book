<html class="js flexbox fontface" lang="en" style=""><head><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Real World OCaml</title><link rel="stylesheet" href="css/app.css"/><script src="js/min/modernizr-min.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a href="toc.html" class="to-chapter"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body">
    <section xmlns="http://www.w3.org/1999/xhtml" id="handling-json-data" data-type="chapter">
      <h1>Handling JSON Data</h1>

      <p>
	Data serialization, i.e., converting data to and from a
	sequence of bytes that's suitable for writing to disk or
	sending across the network, is an important and common
	programming task. You often have to match someone else's data
	format (such as XML), sometimes you need a highly efficient
	format, and other times you want something that is easy for
	humans to edit. To this end, OCaml libraries provide several
	techniques for data serialization depending on what your
	problem is.

	<a data-type="indexterm" data-primary="JSON data" data-secondary="basics of">&nbsp;</a>
	<a data-type="indexterm" data-primary="serialization formats" data-secondary="JSON" id="SERjson">&nbsp;</a>
	<a data-type="indexterm" data-primary="data serialization" data-secondary="with JSON" id="DATjson">&nbsp;</a></p>

      <p>
	We'll start by using the popular and simple JSON data format
	and then look at other serialization formats later in the book.
	This chapter introduces you to a couple of new techniques that
	glue together the basic ideas from Part I of the book by
	using:</p>

      <ul>
	<li>
          <p>
	    <em>Polymorphic variants</em> to write more extensible
            libraries and protocols (but still retain the ability to
            extend them if needed)</p>
	</li>

	<li>
          <p>
	    <em>Functional combinators</em> to compose common
            operations over data structures in a type-safe way</p>
	</li>

	<li>
          <p>
	    External tools to generate boilerplate OCaml modules and
            signatures from external specification files</p>
	</li>
      </ul>

      <section id="json-basics" data-type="sect1">
	<h1>JSON Basics</h1>

	<p>
	  JSON is a lightweight data-interchange format often used in
	  web services and browsers. It's described
	  in <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</a>
	  and is easier to parse and generate than alternatives such
	  as XML.  You'll run into JSON very often when working with
	  modern web APIs, so we'll cover several different ways to
	  manipulate it in this chapter.

	  <a data-type="indexterm" data-primary="RFC4627">&nbsp;</a></p>

	<p>
	  JSON consists of two basic structures: an unordered
	  collection of key/value pairs, and an ordered list of values.
	  Values can be strings, Booleans, floats, integers, or null.
	  Let's see what a JSON record for an example book description
	  looks like:

	  <a data-type="indexterm" data-primary="values" data-secondary="in JSON data">&nbsp;</a>
	  <a data-type="indexterm" data-primary="key" data-secondary="value pairs">&nbsp;</a></p>

	<div class="highlight"><pre>{
  "title": "Real World OCaml",
  "tags" : [ "functional programming", "ocaml", "algorithms" ],
  "pages": 450,
  "authors": [
    { "name": "Jason Hickey", "affiliation": "Google" },
    { "name": "Anil Madhavapeddy", "affiliation": "Cambridge"},
    { "name": "Yaron Minsky", "affiliation": "Jane Street"}
  ],
  "is_online": true
}
</pre></div>

	<p>
	  The outermost JSON value is usually a record (delimited by
	  the curly braces) and contains an unordered set of key/value
	  pairs. The keys must be strings, but values can be any JSON
	  type. In the preceding example, <code>tags</code> is a string
	  list, while the <code>authors</code> field contains a list of
	  records. Unlike OCaml lists, JSON lists can contain multiple
	  different JSON types within a single list.</p>

	<p>
	  This free-form nature of JSON types is both a blessing and
	  a curse. It's very easy to generate JSON values, but code
	  that parses them also has to handle subtle variations in how
	  the values are represented. For example, what if the
	  preceding <code>pages</code> value is actually represented as
	  a string value of "<code>450</code>" instead of an
	  integer?

	  <a data-type="indexterm" data-primary="JSON data" data-secondary="benefits and drawbacks of">&nbsp;</a></p>

	<p>
	  Our first task is to parse the JSON into a more structured
	  OCaml type so that we can use static typing more effectively.
	  When manipulating JSON in Python or Ruby, you might write
	  unit tests to check that you have handled unusual inputs. The
	  OCaml model prefers compile-time static checking as well as
	  unit tests. For example, using pattern matching can warn you
	  if you've not checked that a value can be <code>Null</code>
	  as well as contain an actual value.

	  <a data-type="indexterm" data-primary="Yojson library" data-secondary="installation of">&nbsp;</a>
	  <a data-type="indexterm" data-primary="static checking">&nbsp;</a>
	  <a data-type="indexterm" data-primary="compile-time static checking">&nbsp;</a>
	  <a data-type="indexterm" data-primary="unit tests">&nbsp;</a></p>

	<div data-type="note">
          <h1>Installing the Yojson Library</h1>

          <p>
	    There are several JSON libraries available for OCaml.  For
            this chapter, we've picked
            the <a href="http://mjambon.com/yojson.html">Yojson</a>
            library by Martin Jambon. It's easiest to install via OPAM
            by running <code>opam install
            yojson</code>. See <a href="http://realworldocaml.org/install">this
            Real World OCaml
              page</a> for installation instructions if you haven't
            already got OPAM. Once installed, you can open it in the
            <span class="command"><em>utop</em></span> toplevel by:</p>
	</div>

	<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">open</span> <span class="nc">Core_kernel</span> <span class="o">;;</span>
</pre><pre><span></span><span class="o">#</span> <span class="o">#re</span><span class="n">quire</span> <span class="s2">&quot;yojson&quot;</span> <span class="o">;;</span>
</pre><pre class="ge">/home/travis/.opam/4.04.2/lib/easy-format: added to search path
/home/travis/.opam/4.04.2/lib/easy-format/easy_format.cma: loaded
/home/travis/.opam/4.04.2/lib/biniou: added to search path
/home/travis/.opam/4.04.2/lib/biniou/biniou.cma: loaded
/home/travis/.opam/4.04.2/lib/yojson: added to search path
/home/travis/.opam/4.04.2/lib/yojson/yojson.cma: loaded</pre><pre><span></span><span class="o">#</span> <span class="k">open</span> <span class="nc">Yojson</span> <span class="o">;;</span>
</pre></div>
      </section>

      <section id="parsing-json-with-yojson" data-type="sect1">
	<h1>Parsing JSON with Yojson</h1>

	<p>
	  The JSON specification has very few data types, and the
	  <code>Yojson.Basic.json</code> type that follows is
	  sufficient to express any valid JSON structure:

	  <a data-type="indexterm" data-primary="JSON data" data-secondary="parsing with Yojson">&nbsp;</a>
	  <a data-type="indexterm" data-primary="Yojson library" data-secondary="parsing JSON with">&nbsp;</a></p>

	<div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="o">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="o">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="o">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="o">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="o">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="o">string</span>
<span class="o">]</span>
</pre></div>

	<p>
	  Some interesting properties should leap out at you after
	  reading this definition:</p>

	<ul>
          <li>
            <p>
	      The <code>json</code> type is <em>recursive</em>,
              which is to say that some of the tags refer back to the
              overall <code>json</code> type. In particular,
              <code>Assoc</code> and <code>List</code> types can
              contain references to further JSON values of different
              types. This is unlike the OCaml lists, whose contents
              must be of a uniform type.

	      <a data-type="indexterm" data-primary="recursion" data-secondary="in json types">&nbsp;</a></p>
          </li>

          <li>
            <p>
	      The definition specifically includes a
              <code>Null</code> variant for empty fields. OCaml doesn't
              allow null values by default, so this must be encoded
              explicitly.</p>
          </li>

          <li>
            <p>
	      The type definition uses polymorphic variants and not
              normal variants. This will become significant later, when
              we extend it with custom extensions to the JSON
              format.

	      <a data-type="indexterm" data-primary="polymorphic variant types" data-secondary="in JSON data">&nbsp;</a></p>
          </li>
	</ul>

	<p>
	  Let's parse the earlier JSON example into this type now.
	  The first stop is the <code>Yojson.Basic</code>
	  documentation, where we find these helpful functions:</p>

	<div class="highlight"><pre><span></span><span class="k">val</span> <span class="o">from_string</span> <span class="o">:</span> <span class="o">?buf:</span><span class="nn">Bi_outbuf</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?fname:string</span> <span class="o">-&gt;</span> <span class="o">?lnum:int</span> <span class="o">-&gt;</span>
   <span class="o">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="c">(* Read a JSON value from a string.</span>
<span class="c">   [buf]   : use this buffer at will during parsing instead of</span>
<span class="c">             creating a new one. </span>
<span class="c">   [fname] : data file name to be used in error messages. It does not </span>
<span class="c">             have to be a real file. </span>
<span class="c">   [lnum]  : number of the first line of input. Default is 1. *)</span>

<span class="k">val</span> <span class="o">from_file</span> <span class="o">:</span> <span class="o">?buf:</span><span class="nn">Bi_outbuf</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?fname:string</span> <span class="o">-&gt;</span> <span class="o">?lnum:int</span> <span class="o">-&gt;</span> 
   <span class="o">string</span> <span class="o">-&gt;</span> <span class="n">json</span>
<span class="c">(* Read a JSON value from a file. See [from_string] for the meaning of the optional</span>
<span class="c">   arguments. *)</span>

<span class="k">val</span> <span class="o">from_channel</span> <span class="o">:</span> <span class="o">?buf:</span><span class="nn">Bi_outbuf</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?fname:string</span> <span class="o">-&gt;</span> <span class="o">?lnum:int</span> <span class="o">-&gt;</span>
  <span class="o">in_channel</span> <span class="o">-&gt;</span> <span class="n">json</span>
  <span class="c">(** Read a JSON value from a channel.</span>
<span class="c">      See [from_string] for the meaning of the optional arguments. *)</span>
</pre></div>

	<p>
	  When first reading these interfaces, you can generally
	  ignore the optional arguments (which have the question marks
	  in the type signature), since they should have sensible
	  defaults. In the preceding signature, the optional arguments
	  offer finer control over the memory buffer allocation and
	  error messages from parsing incorrect JSON.</p>

	<p>
	  The type signature for these functions with the optional
	  elements removed makes their purpose much clearer. The three
	  ways of parsing JSON are either directly from a string, from
	  a file on a filesystem, or via a buffered input channel:</p>

	<div class="highlight"><pre><span></span><span class="k">val</span> <span class="o">from_string</span>  <span class="o">:</span> <span class="o">string</span>     <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="o">from_file</span>    <span class="o">:</span> <span class="o">string</span>     <span class="o">-&gt;</span> <span class="n">json</span>
<span class="k">val</span> <span class="o">from_channel</span> <span class="o">:</span> <span class="o">in_channel</span> <span class="o">-&gt;</span> <span class="n">json</span>
</pre></div>

	<p>
	  The next example shows both the <code>string</code> and
	  <code>file</code> functions in action, assuming the JSON
	  record is stored in a file called <em>book.json</em>:</p>

	<div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Core</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Read JSON file into an OCaml string *)</span>
  <span class="k">let</span> <span class="o">buf</span> <span class="o">=</span> <span class="nn">In_channel</span><span class="p">.</span><span class="n">read_all</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>
  <span class="c">(* Use the string JSON constructor *)</span>
  <span class="k">let</span> <span class="n">json1</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_string</span> <span class="o">buf</span> <span class="k">in</span>
  <span class="c">(* Use the file JSON constructor *)</span>
  <span class="k">let</span> <span class="n">json2</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_file</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>
  <span class="c">(* Test that the two values are the same *)</span>
  <span class="o">print_endline</span> <span class="o">(</span><span class="k">if</span> <span class="n">json1</span> <span class="o">=</span> <span class="n">json2</span> <span class="k">then</span> <span class="s2">&quot;OK&quot;</span> <span class="k">else</span> <span class="s2">&quot;FAIL&quot;</span><span class="o">)</span>
</pre></div>

	<p>
	  You can build this by
	  running <span class="command"><em>jbuilder</em></span>:</p>
  <div class="highlight"><pre>(jbuild_version 1)

(executable
  ((name read_json)
   (libraries (core yojson))
  )
)
</pre></div>
	<div class="highlight"><pre>$ jbuilder build read_json.exe
    ocamldep read_json.depends.ocamldep-output
      ocamlc read_json.{cmi,cmo,cmt}
    ocamlopt read_json.{cmx,o}
    ocamlopt read_json.exe
$ ./_build/default/read_json.exe
OK
</pre></div>

	<p>
	  The <code>from_file</code> function accepts an input
	  filename and takes care of opening and closing it for you.
	  It's far more common to use <code>from_string</code> to
	  construct JSON values though, since these strings come in
	  via a network connection (we'll see more of this
	  in <a href="18-concurrent-programming.html#concurrent-programming-with-async" data-type="xref">Chapter 18, Concurrent Programming With Async</a>) or a
	  database. Finally, the example checks that the two input
	  mechanisms actually resulted in the same OCaml data
	  structure.</p>
      </section>

      <section id="selecting-values-from-json-structures" data-type="sect1">
	<h1>Selecting Values from JSON Structures</h1>

	<p>
	  Now that we've figured out how to parse the example JSON
	  into an OCaml value, let's manipulate it from OCaml code and
	  extract specific fields:

	  <a data-type="indexterm" data-primary="values" data-secondary="selecting from JSON structures" id="VALjson">&nbsp;</a>
	  <a data-type="indexterm" data-primary="JSON data" data-secondary="selecting values from" id="JSONselval">&nbsp;</a></p>

	<div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Core</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Read the JSON file *)</span>
  <span class="k">let</span> <span class="n">json</span> <span class="o">=</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">from_file</span> <span class="s2">&quot;book.json&quot;</span> <span class="k">in</span>

  <span class="c">(* Locally open the JSON manipulation functions *)</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="nc">Util</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">title</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;title&quot;</span> <span class="o">|&gt;</span> <span class="o">to_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">tags</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;tags&quot;</span> <span class="o">|&gt;</span> <span class="o">to_list</span> <span class="o">|&gt;</span> <span class="o">filter_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">pages</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;pages&quot;</span> <span class="o">|&gt;</span> <span class="o">to_int</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">is_online</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;is_online&quot;</span> <span class="o">|&gt;</span> <span class="o">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">is_translated</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;is_translated&quot;</span> <span class="o">|&gt;</span> <span class="o">to_bool_option</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">authors</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;authors&quot;</span> <span class="o">|&gt;</span> <span class="o">to_list</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">names</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">authors</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="o">member</span> <span class="s2">&quot;name&quot;</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">to_string)</span> <span class="k">in</span>

  <span class="c">(* Print the results of the parsing *)</span>
  <span class="o">printf</span> <span class="s2">&quot;Title: %s (%d)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">title</span> <span class="o">pages;</span>
  <span class="o">printf</span> <span class="s2">&quot;Authors: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~sep:</span><span class="s2">&quot;, &quot;</span> <span class="o">names);</span>
  <span class="o">printf</span> <span class="s2">&quot;Tags: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">~sep:</span><span class="s2">&quot;, &quot;</span> <span class="o">tags);</span>
  <span class="k">let</span> <span class="o">string_of_bool_option</span> <span class="o">=</span>
    <span class="k">function</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="s2">&quot;&lt;unknown&gt;&quot;</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="bp">true</span> <span class="o">-&gt;</span> <span class="s2">&quot;yes&quot;</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="s2">&quot;no&quot;</span> <span class="k">in</span>
  <span class="o">printf</span> <span class="s2">&quot;Online: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(string_of_bool_option</span> <span class="o">is_online);</span>
  <span class="o">printf</span> <span class="s2">&quot;Translated: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(string_of_bool_option</span> <span class="o">is_translated)</span>
</pre></div>

	<p>
	  Now build and run this in the same way as the previous
	  example:</p>
  <div class="highlight"><pre>(jbuild_version 1)

(executable
  ((name parse_book)
   (libraries (core yojson))
  )
)
</pre></div>
	<div class="highlight"><pre>$ jbuilder build parse_book.exe
    ocamldep parse_book.depends.ocamldep-output
      ocamlc parse_book.{cmi,cmo,cmt}
    ocamlopt parse_book.{cmx,o}
    ocamlopt parse_book.exe
$ ./_build/default/parse_book.exe
Title: Real World OCaml (450)
Authors: Jason Hickey, Anil Madhavapeddy, Yaron Minsky
Tags: functional programming, ocaml, algorithms
Online: yes
Translated: &lt;unknown&gt;
</pre></div>

	<p>
	  This code introduces the <code>Yojson.Basic.Util</code>
	  module, which contains <em>combinator</em> functions that let
	  you easily map a JSON object into a more strongly typed OCaml
	  value.

	  <a data-type="indexterm" data-primary="combinators" data-secondary="functional combinators">&nbsp;</a>
	  <a data-type="indexterm" data-primary="functional combinators">&nbsp;</a></p>

	<aside data-type="sidebar">
          <h5>Functional Combinators</h5>

          <p>
	    Combinators are a design pattern that crops up quite
            often in functional programming. John Hughes defines them
            as "a function which builds program fragments from program
            fragments." In a functional language, this generally means
            higher-order functions that combine other functions to
            apply useful transformations over values.</p>

          <p>
	    You've already run across several of these in the
            <code>List</code> module:</p>

          <div class="highlight"><pre><span></span><span class="k">val</span> <span class="o">map</span>  <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">f:(</span><span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">b)</span>   <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">b</span> <span class="o">list</span>
<span class="k">val</span> <span class="o">fold</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">init:</span><span class="k">&#39;</span><span class="o">accum</span> <span class="o">-&gt;</span> <span class="o">f:(</span><span class="k">&#39;</span><span class="o">accum</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">accum)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="o">accum</span>
</pre></div>

          <p>
	    <code>map</code> and <code>fold</code> are extremely
            common combinators that transform an input list by applying
            a function to each value of the list. The <code>map</code>
            combinator is simplest, with the resulting list being
            output directly. <code>fold</code> applies each value in
            the input list to a function that accumulates a single
            result, and returns that instead:</p>

          <div class="highlight"><pre><span></span><span class="k">val</span> <span class="o">iter</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">a</span> <span class="o">list</span> <span class="o">-&gt;</span> <span class="o">f:(</span><span class="k">&#39;</span><span class="o">a</span> <span class="o">-&gt;</span> <span class="o">unit)</span> <span class="o">-&gt;</span> <span class="o">unit</span>
</pre></div>

          <p>
	    <code>iter</code> is a more specialized combinator that
            is only useful when writing imperative code. The input
            function is applied to every value, but no result is
            supplied. The function must instead apply some side effect
            such as changing a mutable record field or printing to the
            standard output.</p>
	</aside>

	<p>
	  <code>Yojson</code> provides several combinators in
	  the <code>Yojson.Basic.Util</code> module, some of which are
	  listed in <a href="15-json.html#table15_1" data-type="xref">Table15_1</a>.

	  <a data-type="indexterm" data-primary="combinators" data-secondary="in Yojson library">&nbsp;</a>
	  <a data-type="indexterm" data-primary="Yojson library" data-secondary="combinators in">&nbsp;</a></p>

	<table id="table15_1">
          <caption>
            Yojson combinators
          </caption>

          <thead>
            <tr>
              <th>Function</th>

              <th>Type</th>

              <th>Purpose</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>member</td>

              <td><code>string -&gt; json -&gt; json</code></td>

              <td>Select a named field from a JSON record.</td>
            </tr>

            <tr>
              <td>to_string</td>

              <td><code>json -&gt; string</code></td>

              <td>Convert a JSON value into an OCaml
		<code>string</code>. Raises an exception if this is
		impossible.</td>
            </tr>

            <tr>
              <td>to_int</td>

              <td><code>json -&gt; int</code></td>

              <td>Convert a JSON value into an OCaml
		<code>int</code>. Raises an exception if this is
		impossible.</td>
            </tr>

            <tr>
              <td>filter_string</td>

              <td><code>json list -&gt; string list</code></td>

              <td>Filter valid strings from a list of JSON fields,
		and return them as an OCaml list of strings.</td>
            </tr>
          </tbody>
	</table>

	<p>
	  We'll go through each of these uses one by one now. The
	  following examples also use the <code>|&gt;</code>
	  pipe-forward operator that we explained
	  in <a href="02-variables-and-functions.html#variables-and-functions" data-type="xref">Chapter 2, Variables And Functions</a>. This lets us
	  chain together multiple JSON selection functions and feed
	  the output from one into the next one, without having to
	  create separate <code>let</code> bindings for each one.

	  <a data-type="indexterm" data-primary="filter_string function">&nbsp;</a>
	  <a data-type="indexterm" data-primary="to_init function">&nbsp;</a>
	  <a data-type="indexterm" data-primary="functions" data-secondary="to_init function">&nbsp;</a>
	  <a data-type="indexterm" data-primary="to_string function">&nbsp;</a>
	  <a data-type="indexterm" data-primary="functions" data-secondary="to_string function">&nbsp;</a>
	  <a data-type="indexterm" data-primary="functions" data-secondary="member functions">&nbsp;</a>
	  <a data-type="indexterm" data-primary="member function">&nbsp;</a></p>

	<p>
	  Let's start with selecting a single <code>title</code>
	  field from the record:</p>

	<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">open</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="nc">Util</span> <span class="o">;;</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">title</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;title&quot;</span> <span class="o">|&gt;</span> <span class="o">to_string</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">title</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;Real World OCaml&quot;</span>
</pre></div>

	<p>
	  The <code>member</code> function accepts a JSON object and
	  named key and returns the JSON field associated with that
	  key, or <code>Null</code>. Since we know that
	  the <code>title</code> value is always a string in our
	  example schema, we want to convert it to an OCaml
	  string. The <code>to_string</code> function performs this
	  conversion and raises an exception if there is an unexpected
	  JSON type. The <code>|&gt;</code> operator provides a
	  convenient way to chain these
	  operations <span class="keep-together">together</span>:</p>

	<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">tags</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;tags&quot;</span> <span class="o">|&gt;</span> <span class="o">to_list</span> <span class="o">|&gt;</span> <span class="o">filter_string</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">tags</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;functional programming&quot;</span><span class="o">;</span> <span class="s2">&quot;ocaml&quot;</span><span class="o">;</span> <span class="s2">&quot;algorithms&quot;</span><span class="o">]</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">pages</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;pages&quot;</span> <span class="o">|&gt;</span> <span class="o">to_int</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">pages</span> <span class="o">:</span> <span class="o">int</span> <span class="o">=</span> <span class="o">450</span>
</pre></div>

	<p>
	  The <code>tags</code> field is similar to
	  <code>title</code>, but the field is a list of strings
	  instead of a single one. Converting this to an OCaml
	  <code>string list</code> is a two-stage process. First, we
	  convert the JSON <code>List</code> to an OCaml list of JSON
	  values and then filter out the <code>String</code> values as
	  an OCaml <code>string list</code>. Remember that OCaml lists
	  must contain values of the same type, so any JSON values that
	  cannot be converted to a <code>string</code> will be skipped
	  from the output of <code>filter_string</code>:</p>

	<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">is_online</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;is_online&quot;</span> <span class="o">|&gt;</span> <span class="o">to_bool_option</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">is_online</span> <span class="o">:</span> <span class="o">bool</span> <span class="o">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="bp">true</span>
</pre><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">is_translated</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;is_translated&quot;</span> <span class="o">|&gt;</span> <span class="o">to_bool_option</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">is_translated</span> <span class="o">:</span> <span class="o">bool</span> <span class="o">option</span> <span class="o">=</span> <span class="nc">None</span>
</pre></div>

	<p>
	  The <code>is_online</code> and <code>is_translated</code>
	  fields are optional in our JSON schema, so no error should be
	  raised if they are not present. The OCaml type is a
	  <code>bool option</code> to reflect this and can be extracted
	  via <code>to_bool_option</code>. In our example JSON, only
	  <code>is_online</code> is present and
	  <code>is_translated</code> will be <code>None</code>:</p>

	<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">authors</span> <span class="o">=</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;authors&quot;</span> <span class="o">|&gt;</span> <span class="o">to_list</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">authors</span> <span class="o">:</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span> <span class="o">list</span> <span class="o">=</span>
  <span class="o">[`</span><span class="nc">Assoc</span>
     <span class="o">[(</span><span class="s2">&quot;name&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Jason Hickey&quot;</span><span class="o">);</span> <span class="o">(</span><span class="s2">&quot;affiliation&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Google&quot;</span><span class="o">)];</span>
   <span class="o">`</span><span class="nc">Assoc</span>
     <span class="o">[(</span><span class="s2">&quot;name&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Anil Madhavapeddy&quot;</span><span class="o">);</span>
      <span class="o">(</span><span class="s2">&quot;affiliation&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Cambridge&quot;</span><span class="o">)];</span>
   <span class="o">`</span><span class="nc">Assoc</span>
     <span class="o">[(</span><span class="s2">&quot;name&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Yaron Minsky&quot;</span><span class="o">);</span>
      <span class="o">(</span><span class="s2">&quot;affiliation&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Jane Street&quot;</span><span class="o">)]]</span>
</pre></div>

	<p>
	  The final use of JSON combinators is to extract all the
	  <code>name</code> fields from the list of authors. We first
	  construct the <code>author list</code>, and then
	  <code>map</code> it into a <code>string list</code>. Notice
	  that the example explicitly binds <code>authors</code> to a
	  variable name. It can also be written more succinctly using
	  the pipe-forward operator:</p>

	<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">names</span> <span class="o">=</span>
    <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">member</span> <span class="s2">&quot;authors&quot;</span> <span class="o">|&gt;</span> <span class="o">to_list</span> 
    <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~f:(</span><span class="k">fun</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="o">member</span> <span class="s2">&quot;name&quot;</span> <span class="n">json</span> <span class="o">|&gt;</span> <span class="o">to_string)</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">names</span> <span class="o">:</span> <span class="o">string</span> <span class="o">list</span> <span class="o">=</span>
  <span class="o">[</span><span class="s2">&quot;Jason Hickey&quot;</span><span class="o">;</span> <span class="s2">&quot;Anil Madhavapeddy&quot;</span><span class="o">;</span> <span class="s2">&quot;Yaron Minsky&quot;</span><span class="o">]</span>
</pre></div>

	<p>
	  This style of programming, which omits variable names and
	  chains functions together, is known as <em>point-free
	    programming</em>. It's a succinct style but shouldn't be
	  overused due to the increased difficulty of debugging
	  intermediate values. If an
	  explicit <span class="keep-together">name</span> is assigned
	  to each stage of the transformations, debuggers in
	  particular have an easier time making the program flow
	  simpler to represent to the programmer.</p>

	<p>
	  This technique of using statically typed parsing functions
	  is very powerful in combination with the OCaml type system.
	  Many errors that don't make sense at runtime (for example,
	  mixing up lists and objects) will be caught statically via a
	  type error.

	  <a data-type="indexterm" data-startref="JSONselval">&nbsp;</a>
	  <a data-type="indexterm" data-startref="VALjson">&nbsp;</a></p>
      </section>

      <section id="constructing-json-values" data-type="sect1">
	<h1>Constructing JSON Values</h1>

	<p>
	  Building and printing JSON values is pretty
	  straightforward given the <code>Yojson.Basic.json</code>
	  type. You can just construct values of type <code>json</code>
	  and call the <code>to_string</code> function on them. Let's
	  remind ourselves of the <code>Yojson.Basic.json</code> type
	  again:

	  <a data-type="indexterm" data-primary="values" data-secondary="in JSON data">&nbsp;</a>
	  <a data-type="indexterm" data-primary="JSON data" data-secondary="constructing values">&nbsp;</a></p>

	<div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="o">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="o">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="o">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="o">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="o">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="o">string</span>
<span class="o">]</span>
</pre></div>

	<p>
	  We can directly build a JSON value against this type and
	  use the pretty-printing functions in the
	  <code>Yojson.Basic</code> module to display JSON output:</p>

	<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">person</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">[</span> <span class="o">(</span><span class="s2">&quot;name&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Anil&quot;</span><span class="o">)</span> <span class="o">]</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">person</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="o">string</span> <span class="o">])</span> <span class="o">list</span> <span class="o">]</span> <span class="o">=</span>
  <span class="o">`</span><span class="nc">Assoc</span> <span class="o">[(</span><span class="s2">&quot;name&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Anil&quot;</span><span class="o">)]</span>
</pre></div>

	<p>
	  In the preceding example, we've constructed a simple JSON
	  object that represents a single person. We haven't actually
	  defined the type of <code>person</code> explicitly, as we're
	  relying on the magic of polymorphic variants to make this all
	  work.</p>

	<p>
	  The OCaml type system infers a type for
	  <code>person</code> based on how you construct its value. In
	  this case, only the <code>Assoc</code> and
	  <code>String</code> variants are used to define the record,
	  and so the inferred type only contains these fields without
	  knowledge of the other possible allowed variants in JSON
	  records that you haven't used yet (e.g. <code>Int</code> or
	  <code>Null</code>):</p>

	<div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">?std:bool</span> <span class="o">-&gt;</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span> <span class="o">-&gt;</span> <span class="o">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</pre></div>

	<p>
	  The <code>pretty_to_string</code> function has a more
	  explicit signature that requires an argument of type
	  <code>Yojson.Basic.json</code>. When <code>person</code> is
	  applied to <code>pretty_to_string</code>, the inferred type
	  of <code>person</code> is statically checked against the
	  structure of the <code>json</code> type to ensure that
	  they're compatible:</p>

	<div class="highlight"><pre><span></span><span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="o">person</span> <span class="o">;;</span>
</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">string</span> <span class="o">=</span> <span class="s2">&quot;{ </span><span class="se">\&quot;</span><span class="s2">name</span><span class="se">\&quot;</span><span class="s2">: </span><span class="se">\&quot;</span><span class="s2">Anil</span><span class="se">\&quot;</span><span class="s2"> }&quot;</span>
</pre><pre><span></span><span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_channel</span> <span class="o">stdout</span> <span class="o">person</span> <span class="o">;;</span>
</pre><pre class="ge">{ "name": "Anil" }</pre><pre class="ge"><span></span><span class="o">-</span> <span class="o">:</span> <span class="o">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div>

	<p>
	  In this case, there are no problems. Our
	  <code>person</code> value has an inferred type that is a
	  valid subtype of <code>json</code>, and so the conversion to
	  a string just works without us ever having to explicitly
	  specify a type for <code>person</code>. Type inference lets
	  you write more succinct code without sacrificing runtime
	  reliability, as all the uses of polymorphic variants are
	  still checked at compile time.

	  <a data-type="indexterm" data-primary="errors" data-secondary="type errors" data-seealso="error handling">&nbsp;</a>
	  <a data-type="indexterm" data-primary="type checking">&nbsp;</a>
	  <a data-type="indexterm" data-primary="polymorphic variant types" data-secondary="type checking and">&nbsp;</a>
	  <a data-type="indexterm" data-primary="type inference" data-secondary="benefits of">&nbsp;</a></p>

	<aside data-type="sidebar">
          <h5>Polymorphic Variants and Easier Type Checking</h5>

          <p>
	    One difficulty you will encounter is that type errors
            involving polymorphic variants can be quite verbose. For
            example, suppose you build an <code>Assoc</code> and
            mistakenly include a single value instead of a list of
            keys:</p>

          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">person</span> <span class="o">=</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;name&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Anil&quot;</span><span class="o">);;</span>
</pre><pre class="ge"><span></span><span class="k">val</span> <span class="o">person</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">string</span> <span class="o">*</span> <span class="o">[&gt;</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="o">string</span> <span class="o">]</span> <span class="o">]</span> <span class="o">=</span>
  <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;name&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Anil&quot;</span><span class="o">)</span>
</pre><pre><span></span><span class="o">#</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">pretty_to_string</span> <span class="o">person</span> <span class="o">;;</span>
</pre><pre class="ge">Characters 30-36:
Error: This expression has type
         [&gt; `Assoc of string * [&gt; `String of string ] ]
       but an expression was expected of type Yojson.Basic.json
       Types for tag `Assoc are incompatible</pre></div>

          <p>
	    The type error is more verbose than it needs to be,
            which can be inconvenient to wade through for larger
            values. You can help the compiler to narrow down this error
            to a shorter form by adding explicit type annotations as a
            hint about your intentions:</p>

          <div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="o">(person</span> <span class="o">:</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span><span class="o">)</span> <span class="o">=</span>
    <span class="o">`</span><span class="nc">Assoc</span> <span class="o">(</span><span class="s2">&quot;name&quot;</span><span class="o">,</span> <span class="o">`</span><span class="nc">String</span> <span class="s2">&quot;Anil&quot;</span><span class="o">);;</span>
</pre><pre class="ge">Characters 44-68:
Error: This expression has type 'a * 'b
       but an expression was expected of type
         (string * Yojson.Basic.json) list</pre></div>

          <p>
	    We've annotated <code>person</code> as being of type
            <code>Yojson.Basic.json</code>, and as a result, the
            compiler spots that the argument to the <code>Assoc</code>
            variant has the incorrect type. This illustrates the
            strengths and weaknesses of polymorphic variants: they're
            lightweight and flexible, but the error messages can be
            quite confusing. However, a bit of careful manual type
            annotation makes tracking down such issues much easier.</p>

          <p>
	    We'll discuss more techniques like this that help you
            interpret type errors more easily
            in <a href="22-compiler-frontend.html#the-compiler-frontend-parsing-and-type-checking" data-type="xref">Chapter 22, The Compiler Frontend Parsing And Type
              Checking</a>.</p>
	</aside>
      </section>

      <section id="using-non-standard-json-extensions" data-type="sect1">
	<h1>Using Nonstandard JSON Extensions</h1>

	<p>
	  The standard JSON types are <em>really</em> basic, and
	  OCaml types are far more expressive. Yojson supports an
	  extended JSON format for those times when you're not
	  interoperating with external systems and just want a
	  convenient human-readable, local format. The
	  <code>Yojson.Safe.json</code> type is a superset of the
	  <code>Basic</code> polymorphic variant and looks like
	  this:

	  <a data-type="indexterm" data-primary="Yojson library" data-secondary="extended JSON format support">&nbsp;</a>
	  <a data-type="indexterm" data-primary="JSON data" data-secondary="nonstandard extensions for">&nbsp;</a></p>

	<div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">json</span> <span class="o">=</span> <span class="o">[</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Assoc</span> <span class="k">of</span> <span class="o">(string</span> <span class="o">*</span> <span class="n">json</span><span class="o">)</span> <span class="o">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="o">bool</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Float</span> <span class="k">of</span> <span class="o">float</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Floatlit</span> <span class="k">of</span> <span class="o">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Int</span> <span class="k">of</span> <span class="o">int</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Intlit</span> <span class="k">of</span> <span class="o">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">List</span> <span class="k">of</span> <span class="n">json</span> <span class="o">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Null</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">String</span> <span class="k">of</span> <span class="o">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Stringlit</span> <span class="k">of</span> <span class="o">string</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="n">json</span> <span class="o">list</span>
  <span class="o">|</span> <span class="o">`</span><span class="nc">Variant</span> <span class="k">of</span> <span class="o">string</span> <span class="o">*</span> <span class="n">json</span> <span class="o">option</span>
<span class="o">]</span>
</pre></div>

	<p>
	  The <code>Safe.json</code> type includes all of the
	  variants from <code>Basic.json</code> and extends it with a
	  few more useful ones. A standard JSON type such as a
	  <code>String</code> will type-check against both the
	  <code>Basic</code> module and also the nonstandard
	  <code>Safe</code> module. If you use the extended values with
	  the <code>Basic</code> module, however, the compiler will
	  reject your code until you make it compliant with the
	  portable subset of JSON.</p>

	<p>
	  Yojson supports the following JSON extensions:

	  <a data-type="indexterm" data-primary="variant types" data-secondary="Yojson support for">&nbsp;</a>
	  <a data-type="indexterm" data-primary="tuples">&nbsp;</a>
	  <a data-type="indexterm" data-primary="lit suffix">&nbsp;</a></p>

	<dl>
          <dt>The <code>lit</code> suffix</dt>

          <dd>
            <p>
	      Denotes that the value is stored as a JSON string. For
              example, a <code>Floatlit</code> will be stored as
              <code>"1.234"</code> instead of <code>1.234</code>.</p>
          </dd>

          <dt>The <code>Tuple</code> type</dt>

          <dd>
            <p>
	      Stored as <code>("abc", 123)</code> instead of a
              list.</p>
          </dd>

          <dt>The <code>Variant</code> type</dt>

          <dd>
            <p>
	      Encodes OCaml variants more explicitly, as
              <code>&lt;"Foo"&gt;</code> or
              <code>&lt;"Bar":123&gt;</code> for a variant with
              parameters.</p>
          </dd>
	</dl>

	<p>
	  The only purpose of these extensions is to have greater
	  control over how OCaml values are represented in JSON (for
	  instance, storing a floating-point number as a JSON string).
	  The output still obeys the same standard format that can be
	  easily exchanged with other languages.</p>

	<p>
	  You can convert a <code>Safe.json</code> to a
	  <code>Basic.json</code> type by using the
	  <code>to_basic</code> function as follows:</p>

	<div class="highlight"><pre><span></span><span class="k">val</span> <span class="o">to_basic</span> <span class="o">:</span> <span class="n">json</span> <span class="o">-&gt;</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Basic</span><span class="p">.</span><span class="n">json</span>
<span class="c">(** Tuples are converted to JSON arrays, Variants are converted to</span>
<span class="c">    JSON strings or arrays of a string (constructor) and a json value</span>
<span class="c">    (argument). Long integers are converted to JSON strings.</span>
<span class="c">    Examples:</span>

<span class="c">    `Tuple [ `Int 1; `Float 2.3 ]   -&gt;    `List [ `Int 1; `Float 2.3 ]</span>
<span class="c">    `Variant (&quot;A&quot;, None)            -&gt;    `String &quot;A&quot;</span>
<span class="c">    `Variant (&quot;B&quot;, Some x)          -&gt;    `List [ `String &quot;B&quot;, x ]</span>
<span class="c">    `Intlit &quot;12345678901234567890&quot;  -&gt;    `String &quot;12345678901234567890&quot;</span>
<span class="c"> *)</span>
</pre></div>
      </section>

      <section id="automatically-mapping-json-to-ocaml-types" data-type="sect1">
	<h1>Automatically Mapping JSON to OCaml Types</h1>

	<p>
	  The combinators described previously make it easy to write
	  functions that extract fields from JSON records, but the
	  process is still pretty manual. When you implement larger
	  specifications, it's much easier to generate the mappings
	  from JSON schemas to OCaml values more mechanically than
	  writing conversion functions individually.

	  <a data-type="indexterm" data-primary="mapping" data-secondary="of JSON to OCaml types" id="MAPjson">&nbsp;</a>
	  <a data-type="indexterm" data-primary="JSON data" data-secondary="automatic mapping of" id="JSONautomap">&nbsp;</a></p>

	<p>
	  We'll cover an alternative JSON processing method that is
	  better for larger-scale JSON handling now, using
	  the <a href="http://mjambon.com/atd-biniou-intro.html">OCaml</a>
	  tool.  This will introduce our first <em>Domain Specific
	    Language</em> that compiles JSON specifications into OCaml
	  modules, which are then used throughout your application.

	  <a data-type="indexterm" data-primary="ATDgen Library" data-secondary="installation of">&nbsp;</a>
	  <a data-type="indexterm" data-primary="Domain Specific Language">&nbsp;</a></p>

	<div data-type="note">
          <h1>Installing the ATDgen Library and Tool</h1>

          <p>
	    ATDgen installs some OCaml libraries that interface with
            Yojson, and also a command-line tool that generates code.
            It can all be installed via OPAM:</p>
	</div>

	<div class="highlight"><pre>$ opam install atdgen
$ atdgen -version
1.2.3
</pre></div>

	<p>
	  The command-line tool will be installed within your
	  <em class="filename">~/.opam</em> directory and should
	  already be on your <code>PATH</code> from running
	  <span class="command"><em>opam config env</em></span>. See
	  <a href="http://realworldocaml.org/install">this Real World
	    OCaml page</a> if this isn't working.</p>

	<section id="atd-basics" data-type="sect2">
          <h2>ATD Basics</h2>

          <p>
	    The idea behind ATD is to specify the format of the JSON
            in a separate file and then run a compiler
            (<span class="command"><em>atdgen</em></span>) that
            outputs OCaml code to construct and parse JSON
            values. This means that you don't need to write any OCaml
            parsing code at all, as it will all be autogenerated for
            you.

	    <a data-type="indexterm" data-primary="ATDgen Library" data-secondary="basics of">&nbsp;</a></p>

          <p>
	    Let's go straight into looking at an example of how this
            works, by using a small portion of the GitHub API. GitHub
            is a popular code hosting and sharing website that
            provides a JSON-based
            web <a href="http://developer.github.com">API</a>. The
            following ATD code fragment describes the GitHub
            authorization API (which is based on a pseudostandard web
            protocol known as OAuth):

	    <a data-type="indexterm" data-primary="GitHub API">&nbsp;</a>
	    <a data-type="indexterm" data-primary="OAuth web protocol">&nbsp;</a></p>

          <div class="highlight"><pre>type scope = [
    User &lt;json name="user"&gt;
  | Public_repo &lt;json name="public_repo"&gt;
  | Repo &lt;json name="repo"&gt;
  | Repo_status &lt;json name="repo_status"&gt;
  | Delete_repo &lt;json name="delete_repo"&gt;
  | Gist &lt;json name="gist"&gt;
]

type app = {
  name: string;
  url: string;
}  &lt;ocaml field_prefix="app_"&gt;

type authorization_request = {
  scopes: scope list;
  note: string;
} &lt;ocaml field_prefix="auth_req_"&gt;

type authorization_response = {
  scopes: scope list;
  token: string;
  app: app;
  url: string;
  id: int;
  ?note: string option;
  ?note_url: string option;
}
</pre></div>

          <p>
	    The ATD specification syntax is deliberately quite
            similar to OCaml type definitions. Every JSON record is
            assigned a type name (e.g., <code>app</code> in the
            preceding example). You can also define variants that are
            similar to OCaml's variant types (e.g., <code>scope</code>
            in the example).</p>
	</section>

	<section id="atd-annotations" data-type="sect2">
          <h2>ATD Annotations</h2>

          <p>
	    ATD does deviate from OCaml syntax due to its support
            for annotations within the specification. The annotations
            can customize the code that is generated for a particular
            target (of which the OCaml backend is of most interest to
            us).

	    <a data-type="indexterm" data-primary="ATDgen Library" data-secondary="annotations in">&nbsp;</a></p>

          <p>
	    For example, the preceding GitHub <code>scope</code>
            field is defined as a variant type, with each option
            starting with an uppercase letter as is conventional for
            OCaml variants. However, the JSON values that come back
            from GitHub are actually lowercase and so aren't exactly
            the same as the option name.</p>

          <p>
	    The annotation <code>&lt;json name="user"&gt;</code>
            signals that the JSON value of the field is
            <code>user</code>, but that the variable name of the parsed
            variant in OCaml should be <code>User</code>. These
            annotations are often useful to map JSON values to reserved
            keywords in OCaml (e.g., <code>type</code>).</p>
	</section>

	<section id="compiling-atd-specifications-to-ocaml" data-type="sect2">
          <h2>Compiling ATD Specifications to OCaml</h2>

          <p>
	    The ATD specification we defined can be compiled to OCaml
            code using
            the <span class="command"><em>atdgen</em></span>
            command-line tool. Let's run the compiler twice to
            generate some OCaml type definitions and a JSON
            serializing module that converts between input data and
            those type definitions.

	    <a data-type="indexterm" data-primary="ATDgen Library" data-secondary="compiling specifications to OCaml">&nbsp;</a></p>

          <p>
	    The <span class="command"><em>atdgen</em></span> command
            will generate some new files in your current directory.
            <code>github_t.ml</code> and <code>github_t.mli</code> will
            contain an OCaml module with types defined that correspond
            to the ATD file:</p>

          <div class="highlight"><pre>$ atdgen -t github.atd
$ atdgen -j github.atd
$ ocamlfind ocamlc -package atd -i github_t.mli
type scope =
    [ `Delete_repo | `Gist | `Public_repo | `Repo | `Repo_status | `User ]
type app = { app_name : string; app_url : string; }
type authorization_response = {
  scopes : scope list;
  token : string;
  app : app;
  url : string;
  id : int;
  note : string option;
  note_url : string option;
}
type authorization_request = {
  auth_req_scopes : scope list;
  auth_req_note : string;
}
</pre></div>

          <p>
	    There is an obvious correspondence to the ATD
            definition. Note that field names in OCaml records in the
            same module cannot shadow one another, and so we instruct
            ATDgen to prefix every field with a name that distinguishes
            it from other records in the same module. For example,
            <code>&lt;ocaml field_prefix="auth_req_"&gt;</code> in the
            ATD spec prefixes every field name in the generated
            <code>authorization_request</code> record with
            <code>auth_req</code>.</p>

          <p>
	    The <code>Github_t</code> module only contains the type
            definitions, while <code>Github_j</code> provides
            serialization functions to and from JSON. You can read the
            <code>github_j.mli</code> to see the full interface, but
            the important functions for most uses are the conversion
            functions to and from a string. For our preceding example,
            this looks like:</p>

          <div class="highlight"><pre><span></span><span class="k">val</span> <span class="o">string_of_authorization_re</span><span class="n">quest</span> <span class="o">:</span>
  <span class="o">?len:int</span> <span class="o">-&gt;</span> <span class="o">authorization_re</span><span class="n">quest</span> <span class="o">-&gt;</span> <span class="o">string</span>
  <span class="c">(** Serialize a value of type {!authorization_request}</span>
<span class="c">      into a JSON string.</span>
<span class="c">      @param len specifies the initial length</span>
<span class="c">                 of the buffer used internally.</span>
<span class="c">                 Default: 1024. *)</span>

<span class="k">val</span> <span class="o">string_of_authorization_response</span> <span class="o">:</span>
  <span class="o">?len:int</span> <span class="o">-&gt;</span> <span class="o">authorization_response</span> <span class="o">-&gt;</span> <span class="o">string</span>
  <span class="c">(** Serialize a value of type {!authorization_response}</span>
<span class="c">      into a JSON string.</span>
<span class="c">      @param len specifies the initial length</span>
<span class="c">                 of the buffer used internally.</span>
<span class="c">                 Default: 1024. *)</span>
</pre></div>

          <p>
	    This is pretty convenient! We've now written a single ATD
            file, and all the OCaml boilerplate to convert between
            JSON and a strongly typed record has been generated for
            us.  You can control various aspects of the serializer by
            passing flags
            to <span class="command"><em>atdgen</em></span>. The
            important ones for JSON are:

	    <a data-type="indexterm" data-primary="-j-defaults" data-primary-sortas="j-defaults">&nbsp;</a>
	    <a data-type="indexterm" data-primary="-j-custom-fields FUNCTION" data-primary-sortas="j-custom">&nbsp;</a>
	    <a data-type="indexterm" data-primary="-j-std flag" data-primary-sortas="j-std">&nbsp;</a>
	    <a data-type="indexterm" data-primary="flags">&nbsp;</a></p>

          <dl>
            <dt><code>-j-std</code></dt>

            <dd>
              <p>
		Converts tuples and variants into standard JSON and
		refuse to print NaN and infinities. You should specify
		this if you intend to interoperate with services that
		aren't using ATD.</p>
            </dd>

            <dt><code>-j-custom-fields FUNCTION</code></dt>

            <dd>
              <p>
		Calls a custom function for every unknown field
		encountered, instead of raising a parsing
		exception.</p>
            </dd>

            <dt><code>-j-defaults</code></dt>

            <dd>
              <p>
		Always explicitly outputs a JSON value if possible.
		This requires the default value for that field to be
		defined in the ATD specification.</p>
            </dd>
          </dl>

          <p>
	    The full <a href="http://mjambon.com/atdgen/atdgen-manual.html">ATD
              specification</a> is quite sophisticated and documented
            online. The ATD compiler can also target formats other than
            JSON and outputs code for other languages (such as Java) if
            you need more interoperability.</p>

          <p>
	    There are also several similar projects that automate the
            code generation
            process. <a href="http://piqi.org">Piqi</a> supports
            conversions between XML, JSON, and the Google protobuf
            format; and <a href="http://thrift.apache.org">Thrift</a>
            supports many other programming languages and includes
            OCaml bindings.</p>
	</section>

	<section id="example-querying-github-organization-information" data-type="sect2">
          <h2>Example: Querying GitHub Organization Information</h2>

          <p>
	    Let's finish up with an example of some live JSON
            parsing from GitHub and build a tool to query organization
            information via their API. Start by looking at the online
            <a href="http://developer.github.com/v3/orgs/">API
              documentation</a> for GitHub to see what the JSON schema
            for retrieving the organization information looks like.

	    <a data-type="indexterm" data-primary="GitHub API">&nbsp;</a>
	    <a data-type="indexterm" data-primary="ATDgen Library" data-secondary="example of">&nbsp;</a></p>

          <p>
	    Now create an ATD file that covers the fields we need.
            Any extra fields present in the response will be ignored by
            the ATD parser, so we don't need a completely exhaustive
            specification of every field that GitHub might send
            back:</p>

          <div class="highlight"><pre>type org = {
  login: string;
  id: int;
  url: string;
  ?name: string option;
  ?blog: string option;
  ?email: string option;
  public_repos: int
}
</pre></div>

          <p>
	    Let's build the OCaml type declaration first by calling
            <code>atdgen -t</code> on the specification file:</p>

          <div class="highlight"><pre>$ atdgen -t github_org.atd
$ cat github_org_t.mli
(* Auto-generated from "github_org.atd" *)


type org = {
  login: string;
  id: int;
  url: string;
  name: string option;
  blog: string option;
  email: string option;
  public_repos: int
}
</pre></div>

          <p>
	    The OCaml type has an obvious mapping to the ATD spec,
            but we still need the logic to convert JSON buffers to and
            from this type. Calling <code>atdgen -j</code> will
            generate this serialization code for us in a new file
            called <code>github_org_j.ml</code>:</p>

          <div class="highlight"><pre>$ atdgen -j github_org.atd
$ cat github_org_j.mli
(* Auto-generated from "github_org.atd" *)


type org = Github_org_t.org = {
  login: string;
  id: int;
  url: string;
  name: string option;
  blog: string option;
  email: string option;
  public_repos: int
}

val write_org :
  Bi_outbuf.t -&gt; org -&gt; unit
  (** Output a JSON value of type {!org}. *)

val string_of_org :
  ?len:int -&gt; org -&gt; string
  (** Serialize a value of type {!org}
      into a JSON string.
      @param len specifies the initial length
                 of the buffer used internally.
                 Default: 1024. *)

val read_org :
  Yojson.Safe.lexer_state -&gt; Lexing.lexbuf -&gt; org
  (** Input JSON data of type {!org}. *)

val org_of_string :
  string -&gt; org
  (** Deserialize JSON data of type {!org}. *)

</pre></div>

          <p>
	    The <code>Github_org_j</code> serializer interface
            contains everything we need to map to and from the OCaml
            types and JSON. The easiest way to use this interface is by
            using the <code>string_of_org</code> and
            <code>org_of_string</code> functions, but there are also
            more advanced low-level buffer functions available if you
            need higher performance (but we won't go into that in this
            tutorial).</p>

          <p>
	    All we need to complete our example is an OCaml program
            that fetches the JSON and uses these modules to output a
            one-line summary. Our following example does just that.</p>

          <p>
	    The following code calls the cURL command-line utility
            by using the <code>Core_extended.Shell</code> interface to
            run an external command and capture its output. You'll need
            to ensure that you have cURL installed on your system
            before running the example. You might also need to
            <code>opam install core_extended</code> if you haven't
            installed it previously:</p>

          <div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Core</span>

<span class="k">let</span> <span class="o">print_org</span> <span class="o">file</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="o">url</span> <span class="o">=</span> <span class="o">sprintf</span> <span class="s2">&quot;https://api.github.com/orgs/%s&quot;</span> <span class="o">file</span> <span class="k">in</span>
  <span class="nn">Core_extended</span><span class="p">.</span><span class="nn">Shell</span><span class="p">.</span><span class="n">run_full</span> <span class="s2">&quot;curl&quot;</span> <span class="o">[url]</span>
  <span class="o">|&gt;</span> <span class="nn">Github_org_j</span><span class="p">.</span><span class="n">org_of_string</span>
  <span class="o">|&gt;</span> <span class="k">fun</span> <span class="o">org</span> <span class="o">-&gt;</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Github_org_t</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">name</span> <span class="o">=</span> <span class="nn">Option</span><span class="p">.</span><span class="n">value</span> <span class="o">~default:</span><span class="s2">&quot;???&quot;</span> <span class="o">org.name</span> <span class="k">in</span>
  <span class="o">printf</span> <span class="s2">&quot;%s (%d) with %d public repos</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="o">name</span> <span class="o">org.id</span> <span class="o">org.public_repos</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Command</span><span class="p">.</span><span class="n">basic</span> <span class="o">~summary:</span><span class="s2">&quot;Print Github organization information&quot;</span>
    <span class="nn">Command</span><span class="p">.</span><span class="nn">Spec</span><span class="p">.</span><span class="o">(empty</span> <span class="o">+&gt;</span> <span class="o">anon</span> <span class="o">(</span><span class="s2">&quot;organization&quot;</span> <span class="o">%:</span> <span class="o">string))</span>
    <span class="o">print_org</span>
  <span class="o">|&gt;</span> <span class="nn">Command</span><span class="p">.</span><span class="n">run</span>
</pre></div>

          <p>
	    The following is a short shell script that generates all
            of the OCaml code and also builds the final executable:</p>
          <div class="highlight"><pre>(jbuild_version 1)

(rule
 ((targets (github_org_j.ml github_org_j.mli))
  (deps    (github_org.atd))
  (action  (run atdgen -j ${&lt;}))))

(rule
 ((targets (github_org_t.ml github_org_t.mli))
  (deps    (github_org.atd))
  (action  (run atdgen -t ${&lt;}))))

(executable
  ((name github_org_info)
   (libraries (core yojson atdgen core_extended))
   (modules (github_org_info github_org_t github_org_j))
  )
)
</pre></div>
          <div class="highlight"><pre>$ jbuilder build github_org_info.exe
      atdgen github_org_t.{ml,mli}
      atdgen github_org_j.{ml,mli}
    ocamldep github_org_info.depends.ocamldep-output
    ocamldep github_org_info.dependsi.ocamldep-output
      ocamlc github_org_t.{cmi,cmti}
      ocamlc github_org_j.{cmi,cmti}
    ocamlopt github_org_t.{cmx,o}
      ocamlc github_org_info.{cmi,cmo,cmt}
    ocamlopt github_org_j.{cmx,o}
    ocamlopt github_org_info.{cmx,o}
    ocamlopt github_org_info.exe
</pre></div>

          <p>
	    You can now run the command-line tool with a single
            argument to specify the name of the organization, and it
            will dynamically fetch the JSON from the web, parse it, and
            render the summary to your console:</p>

          <div class="highlight"><pre>$ ./_build/default/github_org_info.exe mirage
MirageOS (131943) with 125 public repos
$ ./_build/default/github_org_info.exe janestreet
??? (3384712) with 141 public repos
</pre></div>

          <p>
	    The JSON returned from the <code>janestreet</code> query
            is missing an organization name, but this is explicitly
            reflected in the OCaml type, since the ATD spec marked
            <code>name</code> as an optional field. Our OCaml code
            explicitly handles this case and doesn't have to worry
            about null-pointer exceptions. Similarly, the JSON integer
            for the <code>id</code> is mapped into a native OCaml
            integer via the ATD conversion.</p>

          <p>
	    While this tool is obviously quite simple, the ability to
            specify optional and default fields is very powerful.
            Take a look at the full ATD specification for the GitHub
            API in
	    the <a href="http://github.com/avsm/ocaml-github"><code>ocaml-github</code></a>
            repository online, which has lots of quirks typical in
            real-world web APIs.

	    <a data-type="indexterm" data-startref="MAPjson">&nbsp;</a>
	    <a data-type="indexterm" data-startref="JSONautomap">&nbsp;</a>
	    <a data-type="indexterm" data-startref="SERjson">&nbsp;</a>
	    <a data-type="indexterm" data-startref="DATjson">&nbsp;</a></p>

          <p>
	    Our example shells out to <code>curl</code> on the command
            line to obtain the JSON, which is rather
            inefficient. We'll explain how to integrate the HTTP fetch
            directly into your OCaml application
            in <a href="18-concurrent-programming.html#concurrent-programming-with-async" data-type="xref">Chapter 18, Concurrent Programming With
            Async</a>.</p>
	</section>
      </section>
    </section>
  </article></div><a class="next-chapter" href="16-parsing-with-ocamllex-and-menhir.html"><div class="content"><h1><small>Next: Chapter 16</small>Parsing with OCamllex and Menhir</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://plus.google.com/111219778721183890368">+hickey</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2014 Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script><script src="js/discourse.js"></script></body></html>